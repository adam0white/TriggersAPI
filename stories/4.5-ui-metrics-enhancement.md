---
title: "Story 4.5 - UI Metrics Enhancement: Charts for Latency/Errors, Visual Indicators"
status: "Ready for Development"
epic: "Epic 4: Observability & Tail Worker Logs Display"
priority: "P0"
story_size: "Large"
estimated_hours: 6
created_at: "2025-11-11"
modified_at: "2025-11-11"
---

## Summary

Enhance the metrics dashboard panel with beautiful charts and visualizations for latency percentiles, error rates, throughput, and queue depth. Add visual indicators for system health and performance trends. Replace basic number displays with interactive, real-time updating charts.

## Business Value

Transforms raw metrics into visual insights that are immediately understandable. Charts enable quick identification of performance trends, anomalies, and system health issues. Visual representation is more impactful for demonstrations.

## Technical Context

**From PRD (FR-4.2: Metrics Collection):**
- Dashboard MUST display:
  - Processing latency distributions (from Tail Worker data)
  - Event flow visualization

**From PRD (FR-5.2: Real-Time Metrics Display):**
- Dashboard MUST display with auto-refresh every 5 seconds
- Error rates and retry patterns
- Queue depth and batch processing stats
- Processing latency distributions
- Responsive grid layout

**From Architecture:**
- Metrics stored in KV (real-time) and D1 (historical)
- Dashboard is React-based with shadcn components

## Acceptance Criteria

1. **Latency Distribution Chart**
   - Line chart showing latency percentiles (p50, p95, p99) over time
   - X-axis: time (last hour, updated every 5 minutes)
   - Y-axis: latency in milliseconds
   - Separate lines per percentile with different colors (p50=green, p95=yellow, p99=red)
   - Interactive tooltips showing exact values on hover
   - Goal line at 100ms (p95 target from PRD)
   - Chart updates automatically every 30 seconds

2. **Error Rate Chart**
   - Area chart showing error percentage over time
   - X-axis: time (last hour)
   - Y-axis: error percentage (0-100%)
   - Color gradient: green (0-2%), yellow (2-5%), red (5%+)
   - Filled area under curve for visual impact
   - Tooltip shows error count and total requests
   - Trend line showing direction (up/down/stable)

3. **Request Success Rate Visual**
   - Circular progress indicator (0-100%)
   - Center shows current success percentage
   - Ring color indicates health: green (>95%), yellow (90-95%), red (<90%)
   - Smooth animation when value changes
   - Mini sparkline showing trend in last hour

4. **Throughput Chart**
   - Bar chart showing requests per second over time
   - X-axis: time (last hour, 5-minute buckets)
   - Y-axis: requests per second
   - Bars colored by endpoint (/events=blue, /inbox=green, etc.)
   - Stacked bar option for endpoint breakdown
   - Shows peak RPS in last hour

5. **Queue Depth Indicator**
   - Gauge chart showing current queue depth
   - Min: 0, Max: auto-scaling based on peak
   - Color zones: green (0-50), yellow (50-150), red (150+)
   - Current value displayed prominently
   - Trend arrows (↑ increasing, ↓ decreasing, → stable)
   - Last update timestamp

6. **Dead Letter Queue Alert**
   - Highlighted box showing DLQ message count
   - Red background if count > 0
   - Click to view DLQ messages detail
   - Shows DLQ trend (new messages added/resolved in last hour)

7. **Error Type Breakdown**
   - Donut chart showing error distribution
   - Segments: validation, auth, not_found, conflict, server
   - Legend showing count and percentage
   - Click segment to filter logs to that error type
   - Colors match error severity (red for server, orange for client)

8. **CPU Usage Metrics**
   - Gauge showing average CPU time as percentage
   - Max CPU bar showing peak CPU time in last hour
   - Percentile indicators (p50, p95, p99)
   - Helps identify slow operations

9. **Latency by Endpoint Breakdown**
   - Table or bar chart comparing average latency per endpoint
   - Columns: endpoint, avg latency, p95 latency, request count
   - Sorted by slowest endpoint
   - Color coding: green (<100ms), yellow (100-200ms), red (>200ms)
   - Click endpoint to filter logs

10. **System Health Dashboard**
    - Grid of 4-6 metric cards in single view:
      - Success rate (circular progress)
      - Error rate (trend indicator)
      - Queue depth (gauge)
      - Avg latency (big number with trend)
      - Throughput (big number with trend)
      - DLQ count (alert box)
    - Each card auto-updates every 5 seconds
    - Responsive grid (4 cols desktop, 2 cols tablet, 1 col mobile)
    - Each card clickable to drill down

11. **Time Range Selection**
    - Radio buttons or dropdown: Last hour, Last 6 hours, Last 24 hours, Custom
    - Charts update data when time range changes
    - Selected time range persisted in localStorage
    - Default: Last hour

12. **Interactive Tooltips & Legends**
    - Hover any chart point shows detailed information
    - Tooltip shows timestamp, exact value, percentage
    - Legend allows toggling series visibility
    - Click legend to hide/show specific metrics
    - Tooltip formatted clearly with units

13. **Trend Indicators**
    - Small arrow icons indicating trend: ↑ (increasing), ↓ (decreasing), → (stable)
    - Percentage change from previous period (e.g., "+12% from last hour")
    - Color: green if trend is positive (errors down, success up), red if negative
    - Examples: "↓ 2.3%" for error rate, "↑ 15%" for throughput

14. **Auto-Refresh & Real-Time Updates**
    - Metrics refresh every 5-30 seconds (configurable)
    - Smooth animations for value changes (no jarring jumps)
    - Shows "Last updated: 30 seconds ago" timestamp
    - Pause auto-refresh option (for screenshots/demos)
    - Manual refresh button

15. **Performance & Responsiveness**
    - Charts render in < 1 second on first load
    - Updates don't cause full re-renders
    - Smooth animations using requestAnimationFrame
    - No performance impact on page (100% GPU accelerated if possible)
    - Works smoothly even with 500+ metric data points

## Dependencies

- **Story 4.3:** Metrics calculation providing metric values
- **Epic 2 Complete:** Historical metrics in D1
- **Story 4.2:** Logs providing data for calculations

## Technical Specifications

### Charting Library

Recommendation: **Recharts** (React wrapper for charts)
- Lightweight, responsive
- Built on D3.js, excellent for interactive charts
- Good TypeScript support
- Works well with shadcn components

```bash
npm install recharts date-fns
```

### React Metrics Dashboard Component

```typescript
// src/ui/components/MetricsDashboard.tsx
import React, { useState, useEffect } from 'react';
import {
  LineChart, Line, AreaChart, Area, BarChart, Bar,
  PieChart, Pie, Cell, PolarChart, PolarAngleAxis, PolarRadiusAxis, Radar,
  CartesianGrid, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, ComposedChart
} from 'recharts';
import { Card, CardContent, CardHeader, CardTitle, Button, Tabs } from '@/components/ui';
import { format, subHours, subDays } from 'date-fns';

interface MetricsData {
  timestamp: string;
  latency_p50?: number;
  latency_p95?: number;
  latency_p99?: number;
  error_rate?: number;
  success_rate?: number;
  throughput_rps?: number;
  queue_depth?: number;
  cpu_avg?: number;
  cpu_p95?: number;
}

interface ErrorBreakdown {
  validation: number;
  auth: number;
  not_found: number;
  conflict: number;
  server: number;
}

type TimeRange = 'last-hour' | 'last-6-hours' | 'last-24-hours';

export function MetricsDashboard() {
  const [metricsData, setMetricsData] = useState<MetricsData[]>([]);
  const [currentMetrics, setCurrentMetrics] = useState<MetricsData>({
    timestamp: new Date().toISOString(),
  });
  const [errorBreakdown, setErrorBreakdown] = useState<ErrorBreakdown>({
    validation: 0,
    auth: 0,
    not_found: 0,
    conflict: 0,
    server: 0,
  });
  const [timeRange, setTimeRange] = useState<TimeRange>('last-hour');
  const [autoRefresh, setAutoRefresh] = useState(true);
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date());

  // Fetch metrics data from D1
  const fetchMetricsData = async () => {
    try {
      const hoursAgo = timeRange === 'last-hour' ? 1 : timeRange === 'last-6-hours' ? 6 : 24;
      const startTime = subHours(new Date(), hoursAgo).toISOString();

      const response = await fetch(`/api/metrics/history?time_range=${timeRange}`);
      const data = await response.json();

      setMetricsData(data.historical || []);
      setCurrentMetrics(data.current || {});
      setErrorBreakdown(data.error_breakdown || {});
      setLastUpdate(new Date());
    } catch (error) {
      console.error('Failed to fetch metrics:', error);
    }
  };

  // Initial fetch and auto-refresh
  useEffect(() => {
    fetchMetricsData();

    if (!autoRefresh) return;

    const interval = setInterval(() => {
      fetchMetricsData();
    }, 30000); // Update every 30 seconds

    return () => clearInterval(interval);
  }, [timeRange, autoRefresh]);

  const latencyChartData = metricsData.map(d => ({
    time: format(new Date(d.timestamp), 'HH:mm'),
    'P50': d.latency_p50 || 0,
    'P95': d.latency_p95 || 0,
    'P99': d.latency_p99 || 0,
  }));

  const errorChartData = metricsData.map(d => ({
    time: format(new Date(d.timestamp), 'HH:mm'),
    'Error Rate': d.error_rate || 0,
  }));

  const throughputChartData = metricsData.map(d => ({
    time: format(new Date(d.timestamp), 'HH:mm'),
    'RPS': d.throughput_rps || 0,
  }));

  const errorBreakdownData = [
    { name: 'Validation', value: errorBreakdown.validation, fill: '#f97316' },
    { name: 'Auth', value: errorBreakdown.auth, fill: '#ff6b6b' },
    { name: 'Not Found', value: errorBreakdown.not_found, fill: '#4f46e5' },
    { name: 'Conflict', value: errorBreakdown.conflict, fill: '#fbbf24' },
    { name: 'Server', value: errorBreakdown.server, fill: '#ef4444' },
  ];

  const successRate = currentMetrics.success_rate || 0;
  const successColor = successRate > 95 ? '#22c55e' : successRate > 90 ? '#eab308' : '#ef4444';

  return (
    <div className="space-y-6 p-6 bg-gray-50">
      {/* Header with controls */}
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-2xl font-bold">System Metrics</h2>
          <p className="text-sm text-gray-500">
            Last updated {lastUpdate.getMinutes()} seconds ago
          </p>
        </div>
        <div className="flex gap-4">
          <Tabs
            value={timeRange}
            onValueChange={(v) => setTimeRange(v as TimeRange)}
          >
            <Tabs.List>
              <Tabs.Trigger value="last-hour">Last Hour</Tabs.Trigger>
              <Tabs.Trigger value="last-6-hours">Last 6H</Tabs.Trigger>
              <Tabs.Trigger value="last-24-hours">Last 24H</Tabs.Trigger>
            </Tabs.List>
          </Tabs>
          <Button
            size="sm"
            variant={autoRefresh ? 'default' : 'outline'}
            onClick={() => setAutoRefresh(!autoRefresh)}
          >
            {autoRefresh ? '⏸ Auto' : '▶ Auto'}
          </Button>
          <Button
            size="sm"
            variant="outline"
            onClick={fetchMetricsData}
          >
            Refresh
          </Button>
        </div>
      </div>

      {/* Health metrics grid */}
      <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
        {/* Success Rate */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Success Rate</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold" style={{ color: successColor }}>
              {successRate.toFixed(1)}%
            </div>
            <p className="text-xs text-gray-500 mt-1">
              {successRate > 95 ? '↓ Excellent' : successRate > 90 ? '→ Good' : '↑ Needs attention'}
            </p>
          </CardContent>
        </Card>

        {/* Error Rate */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Error Rate</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold" style={{
              color: (currentMetrics.error_rate || 0) < 2 ? '#22c55e' : (currentMetrics.error_rate || 0) < 5 ? '#eab308' : '#ef4444'
            }}>
              {(currentMetrics.error_rate || 0).toFixed(2)}%
            </div>
            <p className="text-xs text-gray-500 mt-1">in last 5 min</p>
          </CardContent>
        </Card>

        {/* Avg Latency */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Avg Latency</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">
              {(currentMetrics.latency_p50 || 0).toFixed(0)}ms
            </div>
            <p className="text-xs text-gray-500 mt-1">p50</p>
          </CardContent>
        </Card>

        {/* Queue Depth */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Queue Depth</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold" style={{
              color: (currentMetrics.queue_depth || 0) < 50 ? '#22c55e' : (currentMetrics.queue_depth || 0) < 150 ? '#eab308' : '#ef4444'
            }}>
              {currentMetrics.queue_depth || 0}
            </div>
            <p className="text-xs text-gray-500 mt-1">pending events</p>
          </CardContent>
        </Card>

        {/* Throughput */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Throughput</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">
              {(currentMetrics.throughput_rps || 0).toFixed(1)}
            </div>
            <p className="text-xs text-gray-500 mt-1">req/sec</p>
          </CardContent>
        </Card>

        {/* P95 Latency */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">P95 Latency</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold" style={{
              color: (currentMetrics.latency_p95 || 0) < 100 ? '#22c55e' : (currentMetrics.latency_p95 || 0) < 200 ? '#eab308' : '#ef4444'
            }}>
              {(currentMetrics.latency_p95 || 0).toFixed(0)}ms
            </div>
            <p className="text-xs text-gray-500 mt-1">target: 100ms</p>
          </CardContent>
        </Card>
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        {/* Latency Percentiles Chart */}
        <Card className="col-span-1 lg:col-span-2">
          <CardHeader>
            <CardTitle>Latency Percentiles Over Time</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={latencyChartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="time" />
                <YAxis label={{ value: 'Latency (ms)', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="P50" stroke="#22c55e" strokeWidth={2} dot={false} />
                <Line type="monotone" dataKey="P95" stroke="#eab308" strokeWidth={2} dot={false} />
                <Line type="monotone" dataKey="P99" stroke="#ef4444" strokeWidth={2} dot={false} />
                {/* Goal line at 100ms */}
                <Line type="monotone" dataKey={() => 100} stroke="#888" strokeDasharray="5 5" name="Target (100ms)" dot={false} />
              </LineChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>

        {/* Error Rate Chart */}
        <Card>
          <CardHeader>
            <CardTitle>Error Rate Trend</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart data={errorChartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="time" />
                <YAxis label={{ value: 'Error %', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Area type="monotone" dataKey="Error Rate" fill="#ef444466" stroke="#ef4444" />
              </AreaChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>

        {/* Throughput Chart */}
        <Card>
          <CardHeader>
            <CardTitle>Request Throughput</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={throughputChartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="time" />
                <YAxis label={{ value: 'RPS', angle: -90, position: 'insideLeft' }} />
                <Tooltip />
                <Bar dataKey="RPS" fill="#3b82f6" />
              </BarChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>

        {/* Error Type Breakdown */}
        <Card>
          <CardHeader>
            <CardTitle>Error Type Distribution</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie
                  data={errorBreakdownData}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={({ name, value, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                  outerRadius={80}
                  dataKey="value"
                >
                  {errorBreakdownData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.fill} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

### API Endpoint for Historical Metrics

```typescript
// src/routes/metrics-api.ts
router.get('/api/metrics/history', async (request, env) => {
  const url = new URL(request.url);
  const timeRange = url.searchParams.get('time_range') || 'last-hour';

  try {
    let hoursAgo = 1;
    if (timeRange === 'last-6-hours') hoursAgo = 6;
    if (timeRange === 'last-24-hours') hoursAgo = 24;

    // Fetch historical metrics
    const startTime = new Date(Date.now() - hoursAgo * 3600000).toISOString();

    const historicalResult = await env.DB.prepare(`
      SELECT timestamp, metric_type, endpoint, value, unit
      FROM metrics_history
      WHERE timestamp > ?
      ORDER BY timestamp ASC
    `).bind(startTime).all();

    // Fetch current metrics from KV
    const latencyMetrics = await env.KV.get('metrics:latency:/events');
    const errorMetrics = await env.KV.get('metrics:errors:rate');
    const throughputMetrics = await env.KV.get('metrics:throughput');
    const queueMetrics = await env.KV.get('metrics:queue');

    // Parse and transform data
    const historical = historicalResult.results || [];
    const latencyData = latencyMetrics ? JSON.parse(latencyMetrics) : {};
    const errorData = errorMetrics ? JSON.parse(errorMetrics) : {};
    const throughputData = throughputMetrics ? JSON.parse(throughputMetrics) : {};
    const queueData = queueMetrics ? JSON.parse(queueMetrics) : {};

    // Build chart data
    const chartData = historical.reduce((acc, row: any) => {
      const timestamp = row.timestamp;
      let entry = acc.find(e => e.timestamp === timestamp);
      if (!entry) {
        entry = { timestamp };
        acc.push(entry);
      }

      if (row.metric_type === 'latency_p50') entry.latency_p50 = row.value;
      if (row.metric_type === 'latency_p95') entry.latency_p95 = row.value;
      if (row.metric_type === 'latency_p99') entry.latency_p99 = row.value;
      if (row.metric_type === 'error_rate') entry.error_rate = row.value;

      return acc;
    }, []);

    // Get error breakdown
    const errorBreakdown = await env.DB.prepare(`
      SELECT error_category, COUNT(*) as count
      FROM log_entries
      WHERE timestamp > ? AND error_category IS NOT NULL
      GROUP BY error_category
    `).bind(startTime).all();

    const breakdown: any = {
      validation: 0,
      auth: 0,
      not_found: 0,
      conflict: 0,
      server: 0,
    };

    if (errorBreakdown.results) {
      for (const row of errorBreakdown.results as any[]) {
        breakdown[row.error_category] = row.count;
      }
    }

    return new Response(
      JSON.stringify({
        historical: chartData,
        current: {
          latency_p50: latencyData.p50,
          latency_p95: latencyData.p95,
          latency_p99: latencyData.p99,
          error_rate: errorData.error_rate,
          success_rate: 100 - (errorData.error_rate || 0),
          throughput_rps: throughputData.rps,
          queue_depth: queueData.queue_depth,
        },
        error_breakdown: breakdown,
        timestamp: new Date().toISOString(),
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Failed to fetch metrics history:', error);
    return new Response(
      JSON.stringify({ error: 'Failed to fetch metrics' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
```

## Implementation Workflow

1. **Install Recharts**
   - Add charting library dependency

2. **Create MetricsDashboard component**
   - State management for time range and metrics data
   - Data fetching and polling

3. **Build individual metric cards**
   - Success rate, error rate, latency, queue depth, throughput
   - Color coding based on thresholds

4. **Implement charts**
   - Latency percentiles line chart
   - Error rate area chart
   - Throughput bar chart
   - Error breakdown pie chart

5. **Add interactivity**
   - Time range selection
   - Auto-refresh toggle
   - Manual refresh button
   - Hover tooltips

6. **Create metrics API endpoint**
   - Fetch historical data from D1
   - Fetch current metrics from KV
   - Format data for charts

7. **Integrate with dashboard**
   - Add MetricsDashboard to main dashboard layout
   - Navigation between metrics and logs panels

8. **Test with real data**
   - Send test requests to generate metrics
   - Verify charts update properly
   - Test time range filtering
   - Verify responsive design

## Verification Checklist

- [ ] All metric cards display current values
- [ ] Latency percentiles chart renders correctly
- [ ] Error rate chart updates in real-time
- [ ] Throughput chart shows data
- [ ] Error breakdown pie chart shows distribution
- [ ] Time range selection updates charts
- [ ] Auto-refresh working (updates every 30 seconds)
- [ ] Charts responsive on mobile/tablet
- [ ] Color coding matches health status
- [ ] Tooltips show detailed information
- [ ] Target line visible on latency chart (100ms)
- [ ] Performance acceptable (no lag/jank)
- [ ] Trend indicators showing correctly

## Notes

- Use Recharts for charts (React-native, good performance)
- Keep historical data window to last 24 hours max (keeps memory low)
- Animate value changes smoothly (0.3s transitions)
- Color coding thresholds from PRD and architecture
- Metrics refresh every 5-30 seconds based on importance

## Related Stories

- **4.3:** Metrics Calculation - provides metric values
- **4.4:** UI Logs Display - related observability panel
- **Story 2.6:** UI Metrics Display (Epic 2) - replaced with enhanced version
