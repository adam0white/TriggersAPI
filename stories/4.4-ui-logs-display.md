---
title: "Story 4.4 - UI Logs Display: Live Tail Logs Streaming, Error Highlighting, Filtering"
status: "Ready for Development"
epic: "Epic 4: Observability & Tail Worker Logs Display"
priority: "P0"
story_size: "Large"
estimated_hours: 7
created_at: "2025-11-11"
modified_at: "2025-11-11"
---

## Summary

Implement a comprehensive live logs panel in the dashboard that streams Tail Worker logs in real-time, provides powerful filtering and search capabilities, highlights errors and warnings, and enables developers to trace requests end-to-end through the system.

## Business Value

Makes system behavior visible to developers, enabling real-time debugging and monitoring. Live logs are critical for demonstrating system correctness and understanding what's happening during event processing.

## Technical Context

**From PRD (FR-5.5: Live Tail Logs):**
- Dashboard MUST stream Tail Worker logs in real-time
- Dashboard MUST display request/response inspection
- Dashboard MUST highlight errors and exceptions
- Dashboard MUST support log filtering/search

**From PRD (FR-4.1: Tail Worker Logging):**
- Tail Worker MUST store logs in accessible format (KV or D1)
- System visibility into system internals for demonstration purposes

**From Architecture:**
- D1 stores parsed logs with structured fields
- KV can optionally cache latest logs
- Dashboard is React-based with shadcn components

## Acceptance Criteria

1. **Real-Time Log Streaming**
   - React component establishes WebSocket or polling connection
   - Fetches latest logs from D1 every 1-2 seconds
   - Displays new logs immediately as they arrive
   - Appends logs to scrollable list (newest at bottom)
   - Maintains max 500 logs in memory (older logs trimmed)
   - No noticeable lag between log creation and display

2. **Log Display Format**
   - Shows timestamp (HH:MM:SS.mmm format, clickable for full ISO-8601)
   - Shows log level as colored badge: debug=gray, info=blue, warn=yellow, error=red
   - Shows worker name (api-worker, queue-consumer, etc.)
   - Shows correlation ID (truncated to 8 chars with tooltip showing full ID)
   - Shows log message (with code syntax highlighting if JSON)
   - Shows method + path + status (for request logs)
   - Shows latency in ms for timing context

3. **Error Highlighting & Visuals**
   - Error log rows highlighted with red background/border
   - Warning log rows highlighted with yellow background
   - Error messages in bold, easy to spot
   - Exception/error details expandable in row detail view
   - Stack traces shown in monospace font
   - Visual distinction between client errors (orange) and server errors (red)

4. **Log Filtering**
   - Filter by log level (debug, info, warn, error) - multi-select checkbox group
   - Filter by worker (api-worker, queue-consumer, etc.) - dropdown
   - Filter by status code (200, 400, 401, 500, etc.) - multi-select
   - Filter by error type (validation, auth, server, etc.) - dropdown
   - Filter by endpoint (/events, /inbox, etc.) - dropdown
   - Filter by correlation ID - text input with autocomplete
   - All filters combine with AND logic
   - "Clear filters" button restores default view

5. **Search & Highlighting**
   - Text search box for log messages
   - Search highlights matching text in yellow
   - Case-insensitive search
   - Search results update live as user types
   - Supports regex patterns (with toggle)
   - Shows "X matches" counter

6. **Correlation ID Tracking**
   - Click on correlation ID to filter all logs for that request
   - Shows all logs from ingestion through storage
   - Displays request → queue → workflow → storage flow
   - Timeline view showing event lifecycle
   - Helps trace issues through entire system

7. **Detail View / Modal**
   - Click log row to open detail modal
   - Shows all log fields in formatted view
   - Shows request/response headers (sanitized)
   - Shows full payload for request logs
   - Shows full stack trace for errors
   - Shows timing breakdown (if available)
   - Copyable content (icon to copy full log as JSON)

8. **Performance Optimization**
   - Virtual scrolling for large log lists (1000+ logs)
   - Only renders visible rows to DOM
   - Efficient updates (only new logs appended)
   - No re-render of entire list on each update
   - Pagination option (if virtual scrolling not preferred)
   - Last 500 logs kept in memory

9. **Time Range Selection**
   - "Last hour", "Last 10 minutes", "Last minute" quick options
   - Custom date/time range picker
   - Shows current time range in component header
   - Fetches logs for selected range on change
   - Remembers last selection in localStorage

10. **Log Grouping**
    - Option to group by: correlation_id, endpoint, worker, status_code
    - Collapsed groups show count and summary
    - Expand group to see individual logs
    - Improves readability for high-volume logs

11. **Export & Sharing**
    - "Export logs" button exports visible logs as JSON
    - "Copy log link" generates shareable URL with filters
    - Can share debugging context (e.g., "show me logs for this request")
    - Download as CSV option

12. **Live Metrics Context**
    - Shows current error rate in header
    - Shows request rate in header
    - Shows queue depth in header
    - Metric values update with logs (every 30 seconds)
    - Helps correlate logs with system health

13. **Responsive Design**
    - Logs panel responsive on mobile/tablet
    - Collapsible filters on small screens
    - Log rows adapt to screen width
    - Touch-friendly controls and buttons
    - Works with split-view dashboard layout

14. **Accessibility**
    - Proper ARIA labels for all controls
    - Keyboard navigation (arrow keys to scroll, Enter to open detail)
    - Screen reader friendly log announcements
    - Color not only indicator (icons for log levels)
    - High contrast mode support

15. **No Performance Impact**
    - Log polling doesn't block UI
    - Filter/search < 100ms response time
    - Smooth scrolling and animations
    - Tail logs panel doesn't slow dashboard

## Dependencies

- **Story 4.1:** Tail Worker capturing logs to D1
- **Story 4.2:** Log processing and parsing
- **Story 4.3:** Metrics calculation (for context display)
- **Epic 2 Complete:** D1 database functional

## Technical Specifications

### D1 Query for Log Retrieval

```typescript
// Get latest logs with optional filters
const buildLogsQuery = (filters?: LogFilters) => {
  let query = `
    SELECT log_id, timestamp, log_level, message, worker_name, correlation_id,
           method, path, endpoint, status_code, duration_ms, error_category,
           request_id, debug_flag
    FROM log_entries
    WHERE timestamp > datetime('now', '-1 hour')
  `;

  if (filters?.levels?.length) {
    const levels = filters.levels.map(l => `'${l}'`).join(',');
    query += ` AND log_level IN (${levels})`;
  }

  if (filters?.workers?.length) {
    const workers = filters.workers.map(w => `'${w}'`).join(',');
    query += ` AND worker_name IN (${workers})`;
  }

  if (filters?.endpoints?.length) {
    const endpoints = filters.endpoints.map(e => `'${e}'`).join(',');
    query += ` AND endpoint IN (${endpoints})`;
  }

  if (filters?.statusCodes?.length) {
    const codes = filters.statusCodes.map(c => `${c}`).join(',');
    query += ` AND status_code IN (${codes})`;
  }

  if (filters?.errorTypes?.length) {
    const types = filters.errorTypes.map(t => `'${t}'`).join(',');
    query += ` AND error_category IN (${types})`;
  }

  if (filters?.correlationId) {
    query += ` AND correlation_id = '${filters.correlationId}'`;
  }

  if (filters?.search) {
    query += ` AND message LIKE '%${filters.search}%'`;
  }

  query += ` ORDER BY timestamp DESC LIMIT ${filters?.limit || 500}`;
  return query;
};
```

### React Component Structure

```typescript
// src/ui/components/TailLogs.tsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { VirtualList } from '@mui/base'; // or react-window
import { Button, Input, Select, MultiSelect, Badge, Tooltip, Modal } from '@/components/ui';
import { formatDistanceToNow, format } from 'date-fns';

interface LogEntry {
  log_id: string;
  timestamp: string;
  log_level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  worker_name: string;
  correlation_id: string;
  method?: string;
  path?: string;
  endpoint?: string;
  status_code?: number;
  duration_ms?: number;
  error_category?: string;
  request_id?: string;
  debug_flag?: string;
}

interface LogFilters {
  levels: string[];
  workers: string[];
  endpoints: string[];
  statusCodes: number[];
  errorTypes: string[];
  correlationId?: string;
  search?: string;
  timeRange: 'last-minute' | 'last-10-minutes' | 'last-hour' | 'custom';
}

export function TailLogs() {
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [filters, setFilters] = useState<LogFilters>({
    levels: ['debug', 'info', 'warn', 'error'],
    workers: [],
    endpoints: [],
    statusCodes: [],
    errorTypes: [],
    timeRange: 'last-10-minutes',
  });
  const [search, setSearch] = useState('');
  const [selectedLog, setSelectedLog] = useState<LogEntry | null>(null);
  const [isDetailOpen, setIsDetailOpen] = useState(false);
  const [metrics, setMetrics] = useState({ errorRate: 0, rps: 0, queueDepth: 0 });
  const logsEndRef = useRef<HTMLDivElement>(null);
  const pollIntervalRef = useRef<NodeJS.Timeout>();

  // Fetch logs on load and when filters change
  useEffect(() => {
    const fetchLogs = async () => {
      try {
        const params = new URLSearchParams();
        params.append('levels', filters.levels.join(','));
        if (filters.workers.length) params.append('workers', filters.workers.join(','));
        if (filters.endpoints.length) params.append('endpoints', filters.endpoints.join(','));
        if (filters.statusCodes.length) params.append('status_codes', filters.statusCodes.join(','));
        if (filters.errorTypes.length) params.append('error_types', filters.errorTypes.join(','));
        if (filters.correlationId) params.append('correlation_id', filters.correlationId);
        if (search) params.append('search', search);
        params.append('limit', '500');

        const response = await fetch(`/api/logs?${params.toString()}`);
        const data = await response.json();
        setLogs(data.logs || []);

        // Auto-scroll to bottom on new logs
        setTimeout(() => logsEndRef.current?.scrollIntoView({ behavior: 'smooth' }), 100);
      } catch (error) {
        console.error('Failed to fetch logs:', error);
      }
    };

    fetchLogs();

    // Poll for new logs every 2 seconds
    pollIntervalRef.current = setInterval(fetchLogs, 2000);

    return () => {
      if (pollIntervalRef.current) clearInterval(pollIntervalRef.current);
    };
  }, [filters, search]);

  // Fetch metrics every 30 seconds
  useEffect(() => {
    const fetchMetrics = async () => {
      try {
        const response = await fetch('/api/metrics');
        const data = await response.json();
        setMetrics({
          errorRate: data.error_rate || 0,
          rps: data.rps || 0,
          queueDepth: data.queue_depth || 0,
        });
      } catch (error) {
        console.error('Failed to fetch metrics:', error);
      }
    };

    fetchMetrics();
    const interval = setInterval(fetchMetrics, 30000);
    return () => clearInterval(interval);
  }, []);

  const filteredLogs = logs.filter(log => {
    if (search && !log.message.toLowerCase().includes(search.toLowerCase())) {
      return false;
    }
    return true;
  });

  const handleFilterChange = (key: string, value: any) => {
    setFilters(prev => ({
      ...prev,
      [key]: value,
    }));
  };

  const handleExport = () => {
    const json = JSON.stringify(filteredLogs, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `logs-${new Date().toISOString()}.json`;
    a.click();
  };

  const handleCopyLink = () => {
    const params = new URLSearchParams();
    if (filters.correlationId) {
      params.append('correlation_id', filters.correlationId);
    }
    const url = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
    navigator.clipboard.writeText(url);
    // Show toast confirmation
  };

  return (
    <div className="flex flex-col h-full gap-4 p-4 bg-white border rounded-lg">
      {/* Header with metrics */}
      <div className="flex justify-between items-center">
        <div className="flex gap-4">
          <Tooltip title="Error rate in last 5 minutes">
            <div className="flex items-center gap-2">
              <Badge variant="error">{metrics.errorRate.toFixed(1)}%</Badge>
              <span className="text-sm text-gray-600">Errors</span>
            </div>
          </Tooltip>
          <Tooltip title="Requests per second">
            <div className="flex items-center gap-2">
              <Badge variant="info">{metrics.rps.toFixed(1)}</Badge>
              <span className="text-sm text-gray-600">RPS</span>
            </div>
          </Tooltip>
          <Tooltip title="Pending events in queue">
            <div className="flex items-center gap-2">
              <Badge variant="warning">{metrics.queueDepth}</Badge>
              <span className="text-sm text-gray-600">Queue Depth</span>
            </div>
          </Tooltip>
        </div>
        <div className="flex gap-2">
          <Button size="sm" variant="outline" onClick={handleExport}>Export</Button>
          <Button size="sm" variant="outline" onClick={handleCopyLink}>Copy Link</Button>
        </div>
      </div>

      {/* Filters */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
        <MultiSelect
          label="Log Level"
          options={['debug', 'info', 'warn', 'error']}
          value={filters.levels}
          onChange={(v) => handleFilterChange('levels', v)}
        />
        <Select
          label="Worker"
          options={['All', 'api-worker', 'queue-consumer']}
          value={filters.workers[0] || 'All'}
          onChange={(v) => handleFilterChange('workers', v === 'All' ? [] : [v])}
        />
        <Select
          label="Endpoint"
          options={['All', '/events', '/inbox', '/inbox/:id/ack', '/inbox/:id/retry']}
          value={filters.endpoints[0] || 'All'}
          onChange={(v) => handleFilterChange('endpoints', v === 'All' ? [] : [v])}
        />
        <Input
          placeholder="Search logs or Correlation ID"
          value={search}
          onChange={(e) => setSearch(e.target.value)}
        />
      </div>

      {/* Logs list */}
      <div className="flex-1 overflow-y-auto border rounded bg-gray-50">
        {filteredLogs.length === 0 ? (
          <div className="p-4 text-center text-gray-500">No logs found</div>
        ) : (
          filteredLogs.map(log => (
            <LogRow
              key={log.log_id}
              log={log}
              search={search}
              onClick={() => {
                setSelectedLog(log);
                setIsDetailOpen(true);
              }}
            />
          ))
        )}
        <div ref={logsEndRef} />
      </div>

      {/* Detail modal */}
      {isDetailOpen && selectedLog && (
        <LogDetailModal
          log={selectedLog}
          isOpen={isDetailOpen}
          onClose={() => setIsDetailOpen(false)}
        />
      )}
    </div>
  );
}

// Log row component with highlighting
function LogRow({ log, search, onClick }: { log: LogEntry; search: string; onClick: () => void }) {
  const levelColors = {
    debug: 'bg-gray-100 text-gray-800',
    info: 'bg-blue-100 text-blue-800',
    warn: 'bg-yellow-100 text-yellow-800',
    error: 'bg-red-100 text-red-800',
  };

  const highlightText = (text: string) => {
    if (!search) return text;
    const parts = text.split(new RegExp(`(${search})`, 'gi'));
    return parts.map((part, i) =>
      part.toLowerCase() === search.toLowerCase() ? (
        <mark key={i} className="bg-yellow-300">{part}</mark>
      ) : (
        part
      )
    );
  };

  return (
    <div
      className={`flex gap-3 p-3 border-b cursor-pointer hover:bg-gray-100 ${
        log.log_level === 'error' ? 'bg-red-50' : ''
      }`}
      onClick={onClick}
    >
      <span className="text-xs text-gray-500 whitespace-nowrap">
        {format(new Date(log.timestamp), 'HH:mm:ss.SSS')}
      </span>
      <Badge className={levelColors[log.log_level]}>{log.log_level}</Badge>
      <span className="text-xs text-gray-500">{log.worker_name}</span>
      <Tooltip title={log.correlation_id}>
        <span className="text-xs text-blue-600 font-mono cursor-help">
          {log.correlation_id.substring(0, 8)}
        </span>
      </Tooltip>
      {log.method && log.status_code && (
        <span className={`text-xs font-mono ${log.status_code < 400 ? 'text-green-600' : 'text-red-600'}`}>
          {log.method} {log.status_code}
        </span>
      )}
      {log.duration_ms && (
        <span className="text-xs text-gray-500">{log.duration_ms}ms</span>
      )}
      <div className="flex-1 text-sm text-gray-700 truncate">
        {highlightText(log.message)}
      </div>
    </div>
  );
}

// Detail modal component
function LogDetailModal({ log, isOpen, onClose }: { log: LogEntry; isOpen: boolean; onClose: () => void }) {
  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <div className="max-w-2xl p-6">
        <h2 className="text-lg font-bold mb-4">Log Detail</h2>
        <div className="space-y-3 font-mono text-sm">
          <div><strong>Log ID:</strong> {log.log_id}</div>
          <div><strong>Timestamp:</strong> {format(new Date(log.timestamp), 'PPpp')}</div>
          <div><strong>Level:</strong> {log.log_level}</div>
          <div><strong>Message:</strong> {log.message}</div>
          <div><strong>Correlation ID:</strong> {log.correlation_id}</div>
          {log.method && <div><strong>Method:</strong> {log.method} {log.path}</div>}
          {log.status_code && <div><strong>Status:</strong> {log.status_code}</div>}
          {log.duration_ms && <div><strong>Duration:</strong> {log.duration_ms}ms</div>}
        </div>
        <div className="mt-6 flex gap-2">
          <Button onClick={() => navigator.clipboard.writeText(JSON.stringify(log, null, 2))}>
            Copy JSON
          </Button>
          <Button variant="outline" onClick={onClose}>Close</Button>
        </div>
      </div>
    </Modal>
  );
}
```

### API Endpoint for Logs Retrieval

```typescript
// src/routes/logs-api.ts
import { Router } from 'itty-router';

const router = Router();

router.get('/api/logs', async (request, env) => {
  const url = new URL(request.url);
  const levels = url.searchParams.get('levels')?.split(',') || ['debug', 'info', 'warn', 'error'];
  const workers = url.searchParams.get('workers')?.split(',') || [];
  const endpoints = url.searchParams.get('endpoints')?.split(',') || [];
  const statusCodes = url.searchParams.get('status_codes')?.split(',').map(Number) || [];
  const errorTypes = url.searchParams.get('error_types')?.split(',') || [];
  const correlationId = url.searchParams.get('correlation_id');
  const search = url.searchParams.get('search') || '';
  const limit = parseInt(url.searchParams.get('limit') || '500', 10);

  try {
    let query = `
      SELECT log_id, timestamp, log_level, message, worker_name, correlation_id,
             method, path, endpoint, status_code, duration_ms, error_category,
             request_id, debug_flag
      FROM log_entries
      WHERE timestamp > datetime('now', '-1 hour')
    `;

    const params: any[] = [];

    if (levels.length) {
      const placeholders = levels.map(() => '?').join(',');
      query += ` AND log_level IN (${placeholders})`;
      params.push(...levels);
    }

    if (workers.length) {
      const placeholders = workers.map(() => '?').join(',');
      query += ` AND worker_name IN (${placeholders})`;
      params.push(...workers);
    }

    if (endpoints.length) {
      const placeholders = endpoints.map(() => '?').join(',');
      query += ` AND endpoint IN (${placeholders})`;
      params.push(...endpoints);
    }

    if (statusCodes.length) {
      const placeholders = statusCodes.map(() => '?').join(',');
      query += ` AND status_code IN (${placeholders})`;
      params.push(...statusCodes);
    }

    if (errorTypes.length) {
      const placeholders = errorTypes.map(() => '?').join(',');
      query += ` AND error_category IN (${placeholders})`;
      params.push(...errorTypes);
    }

    if (correlationId) {
      query += ` AND correlation_id = ?`;
      params.push(correlationId);
    }

    if (search) {
      query += ` AND message LIKE ?`;
      params.push(`%${search}%`);
    }

    query += ` ORDER BY timestamp DESC LIMIT ?`;
    params.push(limit);

    const result = await env.DB.prepare(query).bind(...params).all();

    return new Response(
      JSON.stringify({
        logs: result.results || [],
        count: (result.results || []).length,
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Failed to fetch logs:', error);
    return new Response(
      JSON.stringify({ error: 'Failed to fetch logs' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});

router.get('/api/metrics', async (request, env) => {
  try {
    const errorMetrics = await env.KV.get('metrics:errors:rate');
    const throughputMetrics = await env.KV.get('metrics:throughput');
    const queueMetrics = await env.KV.get('metrics:queue');

    const errorData = errorMetrics ? JSON.parse(errorMetrics) : { error_rate: 0 };
    const throughputData = throughputMetrics ? JSON.parse(throughputMetrics) : { rps: 0 };
    const queueData = queueMetrics ? JSON.parse(queueMetrics) : { queue_depth: 0 };

    return new Response(
      JSON.stringify({
        error_rate: errorData.error_rate,
        rps: throughputData.rps,
        queue_depth: queueData.queue_depth,
        timestamp: new Date().toISOString(),
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Failed to fetch metrics:', error);
    return new Response(
      JSON.stringify({ error: 'Failed to fetch metrics' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});

export default router;
```

## Implementation Workflow

1. **Create D1 query builder for logs**
   - Support multiple filter types
   - Optimize queries with indexes

2. **Implement React TailLogs component**
   - State management for filters and logs
   - Polling mechanism for real-time updates

3. **Create log row with highlighting**
   - Color coding by log level
   - Search result highlighting
   - Click to open detail modal

4. **Implement log detail modal**
   - Full log information display
   - Copy to clipboard functionality
   - Formatted timestamps

5. **Add API endpoints**
   - GET /api/logs with filter support
   - GET /api/metrics for context

6. **Add virtual scrolling** (optional performance optimization)
   - Only render visible logs
   - Smooth scrolling for large lists

7. **Integrate with dashboard**
   - Add TailLogs component to main dashboard
   - Wire up navigation between panels

8. **Test with real logs**
   - Send test requests
   - Verify logs appear in UI within 2 seconds
   - Test filtering and search
   - Verify error highlighting

## Verification Checklist

- [ ] Logs appear in UI within 2 seconds of creation
- [ ] Real-time polling working (new logs appear automatically)
- [ ] All filters working correctly (levels, workers, endpoints, status codes)
- [ ] Search highlights matching text
- [ ] Correlation ID filter shows related logs
- [ ] Error rows highlighted in red
- [ ] Detail modal shows complete log information
- [ ] Export generates valid JSON file
- [ ] Copy link includes filter parameters
- [ ] Virtual scrolling working (if implemented)
- [ ] Metrics display current values
- [ ] Responsive design on mobile/tablet
- [ ] No performance issues with 500+ logs

## Notes

- Use debouncing for search to avoid excessive D1 queries
- Virtual scrolling essential for large log lists (1000+)
- Polling interval (2 seconds) balances freshness with load
- Keep latest 500 logs in memory for UI performance
- Consider WebSocket upgrade for very high-frequency logs

## Related Stories

- **4.1:** Tail Worker Setup - provides raw logs
- **4.2:** Log Processing - parses logs into queryable format
- **4.3:** Metrics Calculation - metrics displayed in header
- **4.5:** UI Metrics Enhancement - related dashboard panel
