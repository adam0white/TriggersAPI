---
title: "Epic 3.5 - UI Event Inbox: Browse Events with Filters, Details, and Action Buttons"
status: "Ready for Development"
epic: "Epic 3: Event Retrieval & Management + Inbox UI"
priority: "P1"
acceptance_criteria:
  - "Event inbox UI component created and accessible in dashboard (tab or section)"
  - "Displays table/list of events with columns: ID, Status, Payload Preview, Created, Retry Count, Actions"
  - "Events auto-loaded on component mount via GET /inbox"
  - "Implements status filter dropdown: All / Pending / Delivered / Failed"
  - "Implements date range picker: from/to ISO-8601 timestamps (or date picker)"
  - "Implements pagination controls: limit dropdown (10/25/50/100) + prev/next buttons"
  - "Shows total event count and current page info (e.g., 'Page 1 of 12, showing 50 of 600')"
  - "Implements event detail modal/drawer: shows full payload and metadata as JSON"
  - "Detail view includes full event information: event_id, all fields, timestamps"
  - "Implements 'Ack' action button (delete): triggers POST /inbox/:id/ack"
  - "Implements 'Retry' action button: triggers POST /inbox/:id/retry (only visible on failed events)"
  - "Action buttons show loading state and disable while request processing"
  - "Success/error toasts show after ack/retry actions"
  - "After ack/retry, event removed/updated from list automatically (no manual refresh)"
  - "Status badges with color coding: pending (yellow), delivered (green), failed (red)"
  - "Payload preview shows first 100 characters truncated with '...' (clickable for full view)"
  - "Timestamps formatted as human-readable (relative time: '2 hours ago')"
  - "Search/filter is responsive (updates list within 500ms)"
  - "Mobile responsive: table converts to card layout on small screens"
  - "Empty state message when no events match filters"
  - "Loading state (spinner) while fetching events"
  - "Error state with retry button if API call fails"
  created_at: "2025-11-11"
modified_at: "2025-11-11"
story_size: "Large"
depends_on: "Epic 3.1 - Inbox Query, Epic 3.3 - Ack Endpoint, Epic 3.4 - Retry Endpoint"
---

## Summary

Build a comprehensive UI component for browsing, filtering, and managing events in the inbox. Integrates with all previous inbox endpoints (query, ack, retry) to provide a complete event management interface.

## Business Value

Provides operators with a user-friendly interface to inspect event status, debug issues, and manage events without using curl. Significantly improves operational observability and troubleshooting capability.

## Technical Requirements

### Event Inbox Component

**File Location:** `src/ui/components/EventInbox.tsx` (or embedded in index.html)

**Component Structure (React approach):**

```typescript
import React, { useEffect, useState } from 'react';
import { ChevronLeft, ChevronRight, Eye, CheckCircle, AlertCircle, RotateCw, Loader2 } from 'lucide-react';

interface Event {
  event_id: string;
  payload: Record<string, any>;
  metadata?: Record<string, any>;
  status: 'pending' | 'delivered' | 'failed';
  created_at: string;
  updated_at: string;
  retry_count: number;
}

interface InboxState {
  events: Event[];
  total: number;
  limit: number;
  offset: number;
  status: 'pending' | 'delivered' | 'failed' | null;
  fromDate: string | null;
  toDate: string | null;
  loading: boolean;
  error: string | null;
  selectedEvent: Event | null;
}

export const EventInbox: React.FC = () => {
  const [state, setState] = useState<InboxState>({
    events: [],
    total: 0,
    limit: 50,
    offset: 0,
    status: null,
    fromDate: null,
    toDate: null,
    loading: false,
    error: null,
    selectedEvent: null,
  });

  const [actionInProgress, setActionInProgress] = useState<Record<string, boolean>>({});
  const [toast, setToast] = useState<{ type: 'success' | 'error'; message: string } | null>(null);

  // Fetch events
  const fetchEvents = async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const params = new URLSearchParams();
      if (state.status) params.append('status', state.status);
      if (state.fromDate) params.append('from', state.fromDate);
      if (state.toDate) params.append('to', state.toDate);
      params.append('limit', state.limit.toString());
      params.append('offset', state.offset.toString());

      const response = await fetch(`/inbox?${params.toString()}`, {
        headers: { 'Authorization': `Bearer ${getAuthToken()}` },
      });

      if (!response.ok) throw new Error('Failed to fetch events');

      const json = await response.json();
      setState(prev => ({
        ...prev,
        events: json.data,
        total: json.total,
        loading: false,
      }));
    } catch (err) {
      setState(prev => ({
        ...prev,
        error: err instanceof Error ? err.message : 'Unknown error',
        loading: false,
      }));
    }
  };

  // Initial load
  useEffect(() => {
    fetchEvents();
  }, [state.status, state.fromDate, state.toDate, state.limit, state.offset]);

  // Acknowledge event
  const handleAck = async (eventId: string) => {
    setActionInProgress(prev => ({ ...prev, [eventId]: true }));

    try {
      const response = await fetch(`/inbox/${eventId}/ack`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${getAuthToken()}` },
      });

      if (!response.ok) throw new Error('Failed to acknowledge event');

      // Remove from list
      setState(prev => ({
        ...prev,
        events: prev.events.filter(e => e.event_id !== eventId),
        total: prev.total - 1,
        selectedEvent: prev.selectedEvent?.event_id === eventId ? null : prev.selectedEvent,
      }));

      showToast('success', `Event ${eventId} acknowledged`);
    } catch (err) {
      showToast('error', `Failed to acknowledge: ${err}`);
    } finally {
      setActionInProgress(prev => ({ ...prev, [eventId]: false }));
    }
  };

  // Retry event
  const handleRetry = async (eventId: string) => {
    setActionInProgress(prev => ({ ...prev, [eventId]: true }));

    try {
      const response = await fetch(`/inbox/${eventId}/retry`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${getAuthToken()}` },
      });

      if (!response.ok) throw new Error('Failed to retry event');

      const json = await response.json();

      // Update event in list
      setState(prev => ({
        ...prev,
        events: prev.events.map(e =>
          e.event_id === eventId
            ? { ...e, status: 'retrying' as const, retry_count: json.data.new_attempt }
            : e
        ),
        selectedEvent:
          prev.selectedEvent?.event_id === eventId
            ? { ...prev.selectedEvent, status: 'retrying', retry_count: json.data.new_attempt }
            : prev.selectedEvent,
      }));

      showToast('success', `Event ${eventId} queued for retry (attempt ${json.data.new_attempt})`);
    } catch (err) {
      showToast('error', `Failed to retry: ${err}`);
    } finally {
      setActionInProgress(prev => ({ ...prev, [eventId]: false }));
    }
  };

  const showToast = (type: 'success' | 'error', message: string) => {
    setToast({ type, message });
    setTimeout(() => setToast(null), 3000);
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'pending':
        return 'bg-yellow-100 text-yellow-800';
      case 'delivered':
        return 'bg-green-100 text-green-800';
      case 'failed':
        return 'bg-red-100 text-red-800';
      case 'retrying':
        return 'bg-blue-100 text-blue-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  const currentPage = Math.floor(state.offset / state.limit) + 1;
  const totalPages = Math.ceil(state.total / state.limit);
  const showingFrom = state.offset + 1;
  const showingTo = Math.min(state.offset + state.limit, state.total);

  return (
    <div className="space-y-6">
      {/* Toast */}
      {toast && (
        <div className={`p-4 rounded-lg ${toast.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
          {toast.message}
        </div>
      )}

      {/* Filters */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div>
          <label className="block text-sm font-medium mb-2">Status</label>
          <select
            value={state.status || ''}
            onChange={(e) => setState(prev => ({ ...prev, status: e.target.value as any || null, offset: 0 }))}
            className="w-full px-3 py-2 border rounded-lg"
          >
            <option value="">All Statuses</option>
            <option value="pending">Pending</option>
            <option value="delivered">Delivered</option>
            <option value="failed">Failed</option>
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">From Date</label>
          <input
            type="datetime-local"
            value={state.fromDate || ''}
            onChange={(e) => setState(prev => ({ ...prev, fromDate: e.target.value || null, offset: 0 }))}
            className="w-full px-3 py-2 border rounded-lg"
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">To Date</label>
          <input
            type="datetime-local"
            value={state.toDate || ''}
            onChange={(e) => setState(prev => ({ ...prev, toDate: e.target.value || null, offset: 0 }))}
            className="w-full px-3 py-2 border rounded-lg"
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Per Page</label>
          <select
            value={state.limit}
            onChange={(e) => setState(prev => ({ ...prev, limit: parseInt(e.target.value), offset: 0 }))}
            className="w-full px-3 py-2 border rounded-lg"
          >
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </div>
      </div>

      {/* Event Info */}
      {state.total > 0 && (
        <p className="text-sm text-gray-600">
          Showing {showingFrom} to {showingTo} of {state.total} events
          {state.status && ` (filtered by ${state.status})`}
        </p>
      )}

      {/* Error State */}
      {state.error && (
        <div className="bg-red-50 border border-red-200 p-4 rounded-lg">
          <p className="text-red-700 mb-2">{state.error}</p>
          <button
            onClick={fetchEvents}
            className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
          >
            Retry
          </button>
        </div>
      )}

      {/* Loading State */}
      {state.loading && (
        <div className="flex items-center justify-center py-8">
          <Loader2 className="w-6 h-6 animate-spin text-blue-600" />
        </div>
      )}

      {/* Empty State */}
      {!state.loading && state.events.length === 0 && (
        <div className="text-center py-8">
          <AlertCircle className="w-12 h-12 text-gray-400 mx-auto mb-3" />
          <p className="text-gray-600">No events match your filters</p>
        </div>
      )}

      {/* Events Table (Desktop) */}
      {!state.loading && state.events.length > 0 && (
        <div className="hidden md:block overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-gray-100 border-b">
              <tr>
                <th className="px-4 py-2 text-left">Event ID</th>
                <th className="px-4 py-2 text-left">Status</th>
                <th className="px-4 py-2 text-left">Payload</th>
                <th className="px-4 py-2 text-left">Created</th>
                <th className="px-4 py-2 text-center">Retries</th>
                <th className="px-4 py-2 text-right">Actions</th>
              </tr>
            </thead>
            <tbody>
              {state.events.map((event) => (
                <tr key={event.event_id} className="border-b hover:bg-gray-50">
                  <td className="px-4 py-3 font-mono text-xs">{event.event_id.substring(0, 8)}...</td>
                  <td className="px-4 py-3">
                    <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(event.status)}`}>
                      {event.status}
                    </span>
                  </td>
                  <td className="px-4 py-3 text-gray-600 truncate max-w-xs">
                    {JSON.stringify(event.payload).substring(0, 100)}...
                  </td>
                  <td className="px-4 py-3 text-gray-600">{formatRelativeTime(event.created_at)}</td>
                  <td className="px-4 py-3 text-center">{event.retry_count}</td>
                  <td className="px-4 py-3 text-right space-x-2">
                    <button
                      onClick={() => setState(prev => ({ ...prev, selectedEvent: event }))}
                      className="px-2 py-1 text-blue-600 hover:bg-blue-50 rounded"
                      title="View details"
                    >
                      <Eye className="w-4 h-4 inline" />
                    </button>
                    {event.status === 'failed' && (
                      <button
                        onClick={() => handleRetry(event.event_id)}
                        disabled={actionInProgress[event.event_id]}
                        className="px-2 py-1 text-orange-600 hover:bg-orange-50 rounded disabled:opacity-50"
                        title="Retry failed event"
                      >
                        <RotateCw className="w-4 h-4 inline" />
                      </button>
                    )}
                    <button
                      onClick={() => handleAck(event.event_id)}
                      disabled={actionInProgress[event.event_id]}
                      className="px-2 py-1 text-green-600 hover:bg-green-50 rounded disabled:opacity-50"
                      title="Acknowledge and delete"
                    >
                      <CheckCircle className="w-4 h-4 inline" />
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* Events Cards (Mobile) */}
      {!state.loading && state.events.length > 0 && (
        <div className="md:hidden space-y-3">
          {state.events.map((event) => (
            <div key={event.event_id} className="border rounded-lg p-4 space-y-2">
              <div className="flex justify-between items-start">
                <span className="font-mono text-xs text-gray-600">{event.event_id.substring(0, 8)}...</span>
                <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(event.status)}`}>
                  {event.status}
                </span>
              </div>
              <p className="text-sm text-gray-600 truncate">
                {JSON.stringify(event.payload).substring(0, 100)}...
              </p>
              <div className="flex justify-between text-xs text-gray-500">
                <span>{formatRelativeTime(event.created_at)}</span>
                <span>Retries: {event.retry_count}</span>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={() => setState(prev => ({ ...prev, selectedEvent: event }))}
                  className="flex-1 px-2 py-1 text-blue-600 border border-blue-600 rounded text-sm hover:bg-blue-50"
                >
                  Details
                </button>
                {event.status === 'failed' && (
                  <button
                    onClick={() => handleRetry(event.event_id)}
                    disabled={actionInProgress[event.event_id]}
                    className="flex-1 px-2 py-1 text-orange-600 border border-orange-600 rounded text-sm hover:bg-orange-50 disabled:opacity-50"
                  >
                    Retry
                  </button>
                )}
                <button
                  onClick={() => handleAck(event.event_id)}
                  disabled={actionInProgress[event.event_id]}
                  className="flex-1 px-2 py-1 text-green-600 border border-green-600 rounded text-sm hover:bg-green-50 disabled:opacity-50"
                >
                  Ack
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Pagination */}
      {state.total > state.limit && (
        <div className="flex justify-between items-center">
          <div />
          <div className="flex gap-2">
            <button
              onClick={() =>
                setState(prev => ({
                  ...prev,
                  offset: Math.max(0, prev.offset - prev.limit),
                }))
              }
              disabled={state.offset === 0}
              className="px-4 py-2 border rounded hover:bg-gray-50 disabled:opacity-50 flex items-center gap-1"
            >
              <ChevronLeft className="w-4 h-4" /> Previous
            </button>
            <div className="flex items-center gap-2 px-4">
              <span className="text-sm text-gray-600">
                Page {currentPage} of {totalPages}
              </span>
            </div>
            <button
              onClick={() =>
                setState(prev => ({
                  ...prev,
                  offset: prev.offset + prev.limit,
                }))
              }
              disabled={state.offset + state.limit >= state.total}
              className="px-4 py-2 border rounded hover:bg-gray-50 disabled:opacity-50 flex items-center gap-1"
            >
              Next <ChevronRight className="w-4 h-4" />
            </button>
          </div>
          <div />
        </div>
      )}

      {/* Detail Modal */}
      {state.selectedEvent && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[80vh] overflow-auto p-6">
            <div className="flex justify-between items-start mb-4">
              <h2 className="text-xl font-bold">Event Details</h2>
              <button
                onClick={() => setState(prev => ({ ...prev, selectedEvent: null }))}
                className="text-gray-500 hover:text-gray-700 text-xl"
              >
                ✕
              </button>
            </div>

            <div className="space-y-4 text-sm">
              <div>
                <label className="font-medium text-gray-700">Event ID</label>
                <code className="block bg-gray-50 p-2 rounded mt-1 font-mono text-xs break-all">
                  {state.selectedEvent.event_id}
                </code>
              </div>

              <div>
                <label className="font-medium text-gray-700">Status</label>
                <p className="mt-1">
                  <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(state.selectedEvent.status)}`}>
                    {state.selectedEvent.status}
                  </span>
                </p>
              </div>

              <div>
                <label className="font-medium text-gray-700">Payload</label>
                <code className="block bg-gray-50 p-2 rounded mt-1 font-mono text-xs overflow-auto max-h-[200px]">
                  {JSON.stringify(state.selectedEvent.payload, null, 2)}
                </code>
              </div>

              {state.selectedEvent.metadata && (
                <div>
                  <label className="font-medium text-gray-700">Metadata</label>
                  <code className="block bg-gray-50 p-2 rounded mt-1 font-mono text-xs overflow-auto max-h-[200px]">
                    {JSON.stringify(state.selectedEvent.metadata, null, 2)}
                  </code>
                </div>
              )}

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="font-medium text-gray-700">Created</label>
                  <p className="mt-1 text-gray-600">{new Date(state.selectedEvent.created_at).toLocaleString()}</p>
                </div>
                <div>
                  <label className="font-medium text-gray-700">Updated</label>
                  <p className="mt-1 text-gray-600">{new Date(state.selectedEvent.updated_at).toLocaleString()}</p>
                </div>
              </div>

              <div>
                <label className="font-medium text-gray-700">Retry Count</label>
                <p className="mt-1">{state.selectedEvent.retry_count}</p>
              </div>
            </div>

            {/* Action Buttons in Modal */}
            <div className="flex gap-2 mt-6">
              {state.selectedEvent.status === 'failed' && (
                <button
                  onClick={() => {
                    handleRetry(state.selectedEvent!.event_id);
                    setState(prev => ({ ...prev, selectedEvent: null }));
                  }}
                  disabled={actionInProgress[state.selectedEvent.event_id]}
                  className="flex-1 px-4 py-2 bg-orange-600 text-white rounded hover:bg-orange-700 disabled:opacity-50"
                >
                  Retry Event
                </button>
              )}
              <button
                onClick={() => {
                  handleAck(state.selectedEvent!.event_id);
                  setState(prev => ({ ...prev, selectedEvent: null }));
                }}
                disabled={actionInProgress[state.selectedEvent.event_id]}
                className="flex-1 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
              >
                Acknowledge
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// Helper functions
function getAuthToken(): string {
  return localStorage.getItem('auth_token') || '';
}

function formatRelativeTime(dateStr: string): string {
  const now = new Date();
  const then = new Date(dateStr);
  const diff = now.getTime() - then.getTime();

  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);

  if (minutes < 1) return 'Just now';
  if (minutes < 60) return `${minutes}m ago`;
  if (hours < 24) return `${hours}h ago`;
  if (days < 7) return `${days}d ago`;

  return then.toLocaleDateString();
}

export default EventInbox;
```

### Integration into Dashboard

**File Location:** `src/ui/index.html` or `src/ui/App.tsx`

Add EventInbox to tabbed dashboard:

```typescript
// In App.tsx (from Epic 2.6)
import { EventInbox } from './components/EventInbox';

<TabsContent value="inbox" className="mt-6">
  <EventInbox />
</TabsContent>
```

### Alternative: HTML Implementation

If using vanilla HTML/CSS/JS (without React), implement as:

```html
<div id="event-inbox" class="space-y-6">
  <!-- Filters -->
  <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
    <div>
      <label class="block text-sm font-medium mb-2">Status</label>
      <select id="status-filter" class="w-full px-3 py-2 border rounded-lg">
        <option value="">All Statuses</option>
        <option value="pending">Pending</option>
        <option value="delivered">Delivered</option>
        <option value="failed">Failed</option>
      </select>
    </div>
    <!-- Similar for other filters... -->
  </div>

  <!-- Events Table -->
  <table id="events-table" class="w-full text-sm">
    <!-- Table implementation -->
  </table>

  <!-- Pagination -->
  <div id="pagination" class="flex justify-between items-center"></div>

  <!-- Detail Modal -->
  <div id="event-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center">
    <!-- Modal content -->
  </div>
</div>

<script>
  // Fetch and update logic in vanilla JavaScript
  async function fetchAndRenderEvents() {
    // Fetch from GET /inbox with filters
    // Render table rows
    // Set up event listeners for ack/retry buttons
  }
</script>
```

---

## Implementation Notes

### What Gets Done

1. Create `src/ui/components/EventInbox.tsx` (React) or update `src/ui/index.html` (vanilla JS)
2. Implement event fetching via GET /inbox with filters
3. Add filter controls: status, date range, limit selector
4. Implement action buttons: View Details, Ack, Retry
5. Create detail modal with full event information
6. Add pagination with prev/next buttons
7. Implement responsive design (table on desktop, cards on mobile)
8. Add loading, error, and empty states
9. Implement action feedback (toasts for success/error)
10. Auto-update list after ack/retry
11. Test all filter combinations
12. Commit: `git add src/ui/ && git commit -m "feat: comprehensive event inbox UI with filters and actions"`

### Development Workflow

1. Ensure all inbox endpoints (3.1, 3.3, 3.4) are working
2. Ensure auth token is stored in localStorage (set via dashboard login)
3. Start: `npx wrangler dev`
4. Open inbox tab and verify:
   - Events load on mount
   - Status filter works
   - Date range filter works
   - Pagination works
   - View details modal opens
   - Ack button removes event
   - Retry button updates status (only on failed events)
5. Test responsive design (resize window)
6. Test error handling (stop backend, verify error state)
7. Test loading state

### Key Architecture Decisions

**Vanilla Components:** No external UI library (except inline styles with Tailwind) - keep dependencies minimal

**Optimistic Updates:** Remove/update events immediately after action (assume success), revert on error

**Auto-Fetch on Filter Change:** Filters change → auto-fetch without manual button

**Detail Modal:** Full event data displayed as JSON (JSON.stringify with formatting)

**Relative Time:** "2 hours ago" more readable than ISO timestamps

---

## Acceptance Criteria Verification Checklist

### UI Components
- [ ] Inbox table/list component renders
- [ ] Status filter dropdown works
- [ ] Date range picker works
- [ ] Limit selector (10/25/50/100) works
- [ ] Pagination prev/next buttons work

### Event Display
- [ ] Event ID shown (truncated)
- [ ] Status badge with colors (yellow/green/red)
- [ ] Payload preview (first 100 chars)
- [ ] Created timestamp (relative time)
- [ ] Retry count displayed

### Actions
- [ ] View Details button opens modal
- [ ] Ack button visible and functional
- [ ] Retry button visible only on failed events
- [ ] Action buttons show loading state
- [ ] Action buttons disabled during request

### Detail Modal
- [ ] Shows full event_id
- [ ] Shows all fields
- [ ] Shows payload as formatted JSON
- [ ] Shows metadata (if present)
- [ ] Shows timestamps
- [ ] Includes ack and retry buttons
- [ ] Can close modal (X button)

### Data Updates
- [ ] Events auto-load on mount
- [ ] Auto-refresh on filter change
- [ ] Event removed after ack
- [ ] Event updated after retry
- [ ] No manual refresh needed

### Feedback
- [ ] Success toast after ack
- [ ] Success toast after retry
- [ ] Error toast on API failure
- [ ] Loading spinner while fetching
- [ ] Error state with retry button

### Responsive Design
- [ ] Desktop: Table layout
- [ ] Mobile: Card layout
- [ ] Touch-friendly button sizes (44x44px min)
- [ ] No horizontal scrolling on mobile

### States
- [ ] Loading state (spinner)
- [ ] Empty state (no filters match)
- [ ] Error state (API failure)
- [ ] Normal state (events displayed)

### Integration
- [ ] Inbox tab in dashboard
- [ ] Uses correct /inbox endpoint
- [ ] Uses /ack endpoint
- [ ] Uses /retry endpoint
- [ ] Auth token from localStorage

---

## Dependencies & Context

**From:** docs/PRD.md (Epic 3 - Event Inbox UI - FR-5.4)
**Architecture:** docs/architecture.md (UI Performance)
**Depends On:**
  - Epic 3.1 (GET /inbox endpoint)
  - Epic 3.3 (POST ack endpoint)
  - Epic 3.4 (POST retry endpoint)
  - Epic 2.6 (Dashboard structure)

**Enables:**
  - Epic 4 (Observability enhancements)
  - Epic 5 (Debug panel)

---

## Dev Notes

- Use debounce on filter changes to avoid excessive API calls
- Relative time ("2 hours ago") better UX than ISO timestamps
- Payload preview truncated at 100 chars - click to expand in modal
- Ack removes event, Retry updates status (different UX)
- Modal prevents accidental closure (button required)
- Optimistic updates improve perceived performance
- Toast auto-dismiss after 3 seconds
- Retry button hidden on non-failed events

---
