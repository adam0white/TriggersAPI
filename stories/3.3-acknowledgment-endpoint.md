---
title: "Epic 3.3 - Acknowledgment Endpoint: POST /inbox/{event_id}/ack with D1 Deletion & Metrics Update"
status: "Ready for Development"
epic: "Epic 3: Event Retrieval & Management + Inbox UI"
priority: "P1"
acceptance_criteria:
  - "POST /inbox/{event_id}/ack endpoint implemented and responds to ack requests"
  - "Endpoint deletes event record from D1 events table (not just marking deleted)"
  - "Endpoint returns 404 Not Found if event_id does not exist in D1"
  - "Endpoint returns 401 Unauthorized if Bearer token missing/invalid"
  - "Deletion is atomic (single SQL DELETE transaction)"
  - "KV metrics updated after successful deletion: decremented from appropriate status bucket"
  - "If event status was pending, decrements metrics:events:pending"
  - "If event status was delivered, decrements metrics:events:delivered"
  - "If event status was failed, decrements metrics:events:failed"
  - "Total events count decremented in KV metrics:events:total"
  - "Response returns event_id, deleted status, and timestamp"
  - "Concurrent ack requests on same event_id handled safely (second returns 404)"
  - "Ack on already-deleted event returns 404 (idempotent in effect)"
  - "Large payloads do not impact deletion performance"
  - "Error during KV update does not prevent D1 deletion (eventual consistency)"
  - "Audit log entry created (correlation_id logged with deletion event)"
created_at: "2025-11-11"
modified_at: "2025-11-11"
story_size: "Medium"
depends_on: "Epic 3.1 - Inbox Query Endpoint, Epic 2.5 - Metrics Updates"
---

## Summary

Implement the POST /inbox/{event_id}/ack endpoint that acknowledges and permanently deletes events from the system. Updates KV metrics to reflect the deletion. Provides cleanup capability for operators to manage event accumulation.

## Business Value

Enables operators to acknowledge and remove processed events from the inbox, preventing the table from growing unbounded. Essential for maintaining system cleanliness and manageable query performance.

## Technical Requirements

### POST /inbox/{event_id}/ack Endpoint

**File Location:** `src/routes/inbox.ts` (add handler)

**Route Handler:**

```typescript
export async function handleAckEvent(
  request: Request,
  env: Env,
  ctx: ExecutionContext,
  eventId: string
): Promise<Response> {
  const correlationId = request.headers.get('x-correlation-id') || generateUUID();

  try {
    // Validate event_id format (UUID-like)
    if (!isValidUUID(eventId)) {
      return errorHandler({
        code: 'INVALID_EVENT_ID',
        message: `Invalid event ID format: ${eventId}`,
        statusCode: 400,
        correlationId,
      });
    }

    const queries = new EventQueries(env.DB);
    const metricsManager = new MetricsManager(env.KV);

    // Retrieve event first (to know its status for metrics update)
    const event = await queries.getEventById(eventId);

    if (!event) {
      console.info(`[${correlationId}] Ack event not found: ${eventId}`);
      return errorHandler({
        code: 'NOT_FOUND',
        message: `Event ${eventId} not found`,
        statusCode: 404,
        correlationId,
      });
    }

    // Delete from D1
    await queries.deleteEvent(eventId);

    // Update metrics in KV (eventual consistency - fire and forget)
    ctx.waitUntil(
      (async () => {
        try {
          // Decrement status-specific count
          await metricsManager.decrementEventStatus(event.status);

          // Decrement total
          await metricsManager.decrementTotalEvents();

          console.info(
            `[${correlationId}] Metrics updated for ack: event_id=${eventId}, status=${event.status}`
          );
        } catch (err) {
          // Log but don't fail the response
          console.error(`[${correlationId}] Failed to update metrics after ack: ${err}`);
        }
      })()
    );

    const response = {
      data: {
        event_id: eventId,
        status: 'deleted',
        timestamp: new Date().toISOString(),
      },
      timestamp: new Date().toISOString(),
    };

    console.info(`[${correlationId}] Event acknowledged and deleted: ${eventId}`);

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
        'X-Correlation-ID': correlationId,
      },
    });
  } catch (error) {
    console.error(`[${correlationId}] Ack event error:`, error);
    return errorHandler({
      code: 'INTERNAL_ERROR',
      message: 'Failed to acknowledge event',
      statusCode: 500,
      correlationId,
    });
  }
}
```

### D1 Query Methods

**File Location:** `src/db/queries.ts` (add methods to EventQueries)

**Event Retrieval and Deletion:**

```typescript
export class EventQueries {
  // ... existing methods ...

  async getEventById(eventId: string): Promise<Event | null> {
    const result = await this.db
      .prepare('SELECT * FROM events WHERE event_id = ?')
      .bind(eventId)
      .first<Event>();

    return result || null;
  }

  async deleteEvent(eventId: string): Promise<void> {
    await this.db
      .prepare('DELETE FROM events WHERE event_id = ?')
      .bind(eventId)
      .run();
  }
}
```

### Metrics Manager Enhancement

**File Location:** `src/lib/metrics.ts` (add decrement methods)

**Metrics Decrement Operations:**

```typescript
export class MetricsManager {
  // ... existing methods ...

  async decrementEventStatus(status: 'pending' | 'delivered' | 'failed'): Promise<void> {
    const key = `metrics:events:${status}`;
    const current = parseInt(await this.kv.get(key) || '0');
    const newValue = Math.max(0, current - 1); // Never go below 0
    await this.kv.put(key, newValue.toString());
  }

  async decrementTotalEvents(): Promise<void> {
    const key = 'metrics:events:total';
    const current = parseInt(await this.kv.get(key) || '0');
    const newValue = Math.max(0, current - 1); // Never go below 0
    await this.kv.put(key, newValue.toString());
  }

  async decrementQueueDepth(): Promise<void> {
    const key = 'metrics:queue:depth';
    const current = parseInt(await this.kv.get(key) || '0');
    const newValue = Math.max(0, current - 1);
    await this.kv.put(key, newValue.toString());
  }
}
```

### Route Registration

**File Location:** `src/index.ts` (update router)

**Register POST ack endpoint:**

```typescript
router.post('/inbox/:event_id/ack', validateAuth, (request, env, context) => {
  const eventId = new URL(request.url).pathname.split('/')[2];
  return handleAckEvent(request, env, context, eventId);
});
```

### API Response Format

**Success Response (200 OK):**

```json
{
  "data": {
    "event_id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "deleted",
    "timestamp": "2025-11-11T10:35:00Z"
  },
  "timestamp": "2025-11-11T10:35:00Z"
}
```

**Error Response - Not Found (404):**

```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "Event 550e8400-e29b-41d4-a716-446655440000 not found",
    "timestamp": "2025-11-11T10:35:00Z",
    "correlation_id": "abc-123-def"
  }
}
```

**Error Response - Invalid Event ID (400):**

```json
{
  "error": {
    "code": "INVALID_EVENT_ID",
    "message": "Invalid event ID format: not-a-uuid",
    "timestamp": "2025-11-11T10:35:00Z",
    "correlation_id": "abc-123-def"
  }
}
```

### Concurrency & Safety

**Atomic Deletion:**

SQLite provides transaction isolation by default. The DELETE statement is atomic:

```sql
-- Single atomic operation
DELETE FROM events WHERE event_id = ?
```

**Concurrent Ack Handling:**

If two requests try to ack the same event simultaneously:
1. First request: `DELETE` succeeds, event removed
2. Second request: `SELECT` returns NULL, responds with 404

This is the desired behavior (idempotent).

**Metrics Eventual Consistency:**

D1 deletion completes immediately, KV update may lag slightly. This is acceptable because:
- UI still shows accurate data from D1 (source of truth)
- Metrics eventually consistent (KV syncs within milliseconds)
- No data loss occurs (event already deleted from D1)

### Edge Cases

**Large Events:**

Deletion performance is unaffected by payload size:
- D1 DELETE is indexed on event_id (PRIMARY KEY)
- Payload size irrelevant to deletion speed

**Already Deleted Events:**

```bash
# Request 1: Succeeds
POST /inbox/uuid-123/ack
# Response: 200 OK

# Request 2: Same event already deleted
POST /inbox/uuid-123/ack
# Response: 404 Not Found (idempotent effect)
```

**Invalid Event ID Format:**

```bash
POST /inbox/not-a-uuid/ack
# Response: 400 Bad Request (invalid event ID format)
```

**Missing Authentication:**

```bash
POST /inbox/uuid-123/ack
# No Authorization header
# Response: 401 Unauthorized
```

---

## Implementation Notes

### What Gets Done

1. Add `handleAckEvent()` function to `src/routes/inbox.ts`
2. Add `getEventById()` method to EventQueries
3. Add `deleteEvent()` method to EventQueries
4. Add `decrementEventStatus()` method to MetricsManager
5. Add `decrementTotalEvents()` method to MetricsManager
6. Register POST /inbox/:event_id/ack route in src/index.ts
7. Add UUID validation helper `isValidUUID()`
8. Test locally with curl commands
9. Verify metrics update after deletion
10. Commit: `git add src/routes/ src/db/ src/lib/ src/index.ts && git commit -m "feat: acknowledgment endpoint for deleting events"`

### Development Workflow

1. Start local dev: `npx wrangler dev`
2. Create a test event via POST /events
3. Get event ID from response
4. Ack the event:
   ```bash
   curl -X POST http://localhost:8787/inbox/EVENT_ID/ack \
     -H "Authorization: Bearer test-token"
   ```
5. Verify event deleted (GET /inbox should not return it)
6. Verify metrics decremented
7. Test 404 on second ack attempt
8. Test invalid event ID
9. Test missing auth

### Key Architecture Decisions

**Fire-and-Forget Metrics Update:** Uses `ctx.waitUntil()` to update KV after response sent. If KV update fails, D1 deletion still completed (safe).

**Atomic D1 Deletion:** Single DELETE statement with indexed lookup - fast and atomic

**Idempotent Semantics:** Second ack returns 404 (same as event never existed), which is acceptable pattern

---

## Acceptance Criteria Verification Checklist

### Endpoint Implementation
- [ ] POST /inbox/{event_id}/ack route registered
- [ ] Handler function in src/routes/inbox.ts
- [ ] Requires Bearer token authentication
- [ ] Returns 401 if missing token

### Event Deletion
- [ ] DELETE statement executes against D1
- [ ] Event removed from events table
- [ ] Response shows "deleted" status
- [ ] Returns 404 if event not found

### Metrics Update
- [ ] Status-specific metric decremented
- [ ] Total events metric decremented
- [ ] Metrics KV keys correct (metrics:events:pending, etc.)
- [ ] Updates happen via eventual consistency (fire-and-forget)

### Response Format
- [ ] Success returns event_id, status: "deleted", timestamp
- [ ] Standard API response structure
- [ ] Timestamp in ISO-8601 format
- [ ] Correlation ID included in headers

### Validation
- [ ] Invalid event ID format rejected (400)
- [ ] Non-existent event returns 404
- [ ] Concurrent ack handled correctly (second gets 404)
- [ ] Large payloads don't impact performance

### Error Handling
- [ ] NOT_FOUND error code for missing event
- [ ] INVALID_EVENT_ID error code for bad format
- [ ] INTERNAL_ERROR code for DB failures
- [ ] All errors include correlation_id

### Concurrency
- [ ] First ack succeeds
- [ ] Second ack returns 404 (safe)
- [ ] No race conditions in deletion
- [ ] Metrics updates don't block response

---

## Dependencies & Context

**From:** docs/PRD.md (Epic 3 - Event Acknowledgment - FR-3.2)
**Architecture:** docs/architecture.md (Error Handling, Metrics)
**Depends On:**
  - Epic 3.1 (GET /inbox to find events)
  - Epic 2.5 (MetricsManager class and KV metrics)

**Enables:**
  - Epic 3.5 (UI with ack button)

---

## Dev Notes

- Correlation IDs enable request tracing through logs
- DELETE by PRIMARY KEY (event_id) is very fast in SQLite
- Metrics eventual consistency acceptable (D1 is source of truth)
- Use ctx.waitUntil() for background tasks (KV update)
- Idempotent: Second ack on deleted event returns 404 (safe)
- isValidUUID() helper prevents invalid queries

---

## Testing Considerations

### Unit Tests

```typescript
// test/routes/ack.test.ts
describe('POST /inbox/:event_id/ack', () => {
  it('deletes event and returns 200', async () => {
    // Setup: Create event
    const createResponse = await fetch('/events', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
      body: JSON.stringify({ payload: { test: true } }),
    });
    const { data: { event_id } } = await createResponse.json();

    // Test: Ack event
    const response = await fetch(`/inbox/${event_id}/ack`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    expect(json.data.status).toBe('deleted');
    expect(json.data.event_id).toBe(event_id);
  });

  it('returns 404 on second ack', async () => {
    // Setup: Create and ack event
    const eventId = 'test-uuid-123';
    // ... create event ...
    await fetch(`/inbox/${eventId}/ack`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    // Test: Second ack
    const response = await fetch(`/inbox/${eventId}/ack`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    expect(response.status).toBe(404);
  });

  it('requires authentication', async () => {
    const response = await fetch('/inbox/test-uuid/ack', {
      method: 'POST',
    });
    expect(response.status).toBe(401);
  });

  it('rejects invalid event ID', async () => {
    const response = await fetch('/inbox/not-a-uuid/ack', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });
    expect(response.status).toBe(400);
    const json = await response.json();
    expect(json.error.code).toBe('INVALID_EVENT_ID');
  });

  it('decrements metrics on delete', async () => {
    // ... similar setup ...
    // Verify metrics decremented after ack
  });
});
```

### Manual Testing

```bash
# Setup
npx wrangler dev

# In another terminal:

# Create an event
EVENT_ID=$(curl -s -X POST http://localhost:8787/events \
  -H "Authorization: Bearer test-token" \
  -H "Content-Type: application/json" \
  -d '{"payload":{"test":true}}' | jq -r '.data.event_id')

echo "Created event: $EVENT_ID"

# Verify event exists
curl -s -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?limit=1" | jq '.data[0].event_id'

# Ack the event
curl -X POST "http://localhost:8787/inbox/$EVENT_ID/ack" \
  -H "Authorization: Bearer test-token"

# Verify event deleted (should not appear in inbox)
curl -s -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox" | jq '.data | map(.event_id) | contains(["'$EVENT_ID'"])'
# Expected: false

# Try to ack again (should 404)
curl -s -X POST "http://localhost:8787/inbox/$EVENT_ID/ack" \
  -H "Authorization: Bearer test-token" | jq '.error.code'
# Expected: "NOT_FOUND"
```

---
