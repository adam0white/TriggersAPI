---
title: "Story 5.3 - Event Flow Visualization: Simple Diagram Showing Ingestion ‚Üí Queue ‚Üí Workflow ‚Üí Storage"
status: "Ready for Development"
epic: "Epic 5: Debug Control Panel + UI Polish"
priority: "P0"
story_size: "Medium"
estimated_hours: 5
created_at: "2025-11-11"
modified_at: "2025-11-11"
---

## Summary

Create an interactive visual diagram showing the event flow through the entire system. Display the journey of events from initial ingestion through queue processing, workflow orchestration, and final storage in D1. Use animated transitions and real-time metrics to show events moving through the system, making the invisible architecture visible.

## Business Value

Transforms abstract system architecture into a tangible visual story. Demo audiences instantly understand how events flow through the system without explanation. Animated metrics show the system is actually processing events in real-time, not just logging them. Makes the system's reliability architecture immediately understandable.

## Technical Context

**From PRD (FR-5.2: Real-Time Metrics Display):**
- Dashboard MUST display: Event flow visualization

**From Architecture:**
- Event flow: Ingestion (Worker) ‚Üí Queue ‚Üí Workflow ‚Üí D1 Storage
- Dead Letter Queue is an alternative endpoint for failed events
- Each stage has measurable metrics

**System Architecture:**
1. **Ingestion Stage:** POST /events endpoint receives requests
2. **Queue Stage:** Valid events sent to Cloudflare Queue
3. **Processing Stage:** Queue triggers Workflow for processing
4. **Storage Stage:** Workflow writes to D1 database
5. **Dead Letter Queue:** Failed events after max retries

## Acceptance Criteria

1. **Flow Diagram Layout**
   - Horizontal flow: Ingestion ‚Üí Queue ‚Üí Processing ‚Üí Storage
   - Optional Dead Letter Queue branch (right side)
   - Responsive: Stacks vertically on mobile
   - SVG-based for crisp rendering
   - Light/dark mode support

2. **Ingestion Stage Box**
   - Label: "Ingestion"
   - Icon: Inbox arrow (incoming)
   - Show metric: Total events received (counter)
   - Real-time update when events submitted
   - Click to expand showing request details
   - Show latest event ID briefly

3. **Queue Stage Box**
   - Label: "Queue"
   - Icon: Hourglass or queue symbol
   - Show metric: Current queue depth (number)
   - Show metric: Events processed in last minute
   - Color changes: green (empty), yellow (moderate load), red (backlog)
   - Pulse animation if depth > 50

4. **Processing Stage Box**
   - Label: "Processing"
   - Icon: Gear or cog
   - Show metric: Events in flight (currently processing)
   - Show metric: Success rate (percentage)
   - Color: Blue (active), Gray (idle)
   - Animated gear when events processing

5. **Storage Stage Box**
   - Label: "Storage"
   - Icon: Database or hard drive
   - Show metric: Total events stored in D1
   - Show metric: Delivered events (green) vs Failed (red)
   - Status breakdown: Pending | Delivered | Failed
   - Clickable to view database summary

6. **Flow Arrows**
   - Directional arrows between stages
   - Animated flow: Events appear to travel along arrows
   - Arrow pulses/activates when events flowing
   - Show throughput number on arrow (events/sec)
   - Thicker arrow for higher throughput

7. **Dead Letter Queue (DLQ) Branch**
   - Right-side branch off Processing stage
   - Label: "Dead Letter Queue"
   - Icon: Warning or X
   - Shows failed events count
   - Red background if count > 0
   - Clickable to view DLQ messages
   - Arrow from Processing only lights up on failures

8. **Event Particle Animation**
   - Small circular particles represent events
   - Travel along arrows from ingestion ‚Üí storage
   - Color-coded by status: blue (processing), green (success), red (error)
   - Spawn at 2-5 second intervals (based on throughput)
   - Disappear at storage stage
   - Smooth motion curve

9. **Real-Time Metrics Update**
   - All counters update every 2 seconds
   - Fetch from `/api/metrics` endpoint
   - Smooth number transitions (animate counter changes)
   - Show up/down arrows for trend
   - Color change on significant changes

10. **Stage Status Indicators**
    - Green: Normal operation (metrics below thresholds)
    - Yellow: Degraded (queue backlog, high failure rate)
    - Red: Critical (queue full, processing failing)
    - Status determined by metric thresholds:
      - Queue depth > 100 ‚Üí Yellow
      - Queue depth > 500 ‚Üí Red
      - Error rate > 5% ‚Üí Yellow
      - Error rate > 10% ‚Üí Red

11. **Metric Detail Popover**
    - Click any stage box to show detailed metrics
    - Popover shows: Count, Trend (‚Üë/‚Üì/‚Üí), Rate (units/sec)
    - Show last update timestamp
    - Dismissible with X button
    - Follows pointer on hover

12. **Time-Series Sparkline**
    - Mini sparkline graph in each stage box
    - Shows metric trend (last 5 minutes)
    - Color gradient: green (positive), red (negative)
    - Updated with each metric refresh
    - Tooltip shows values on hover

13. **Legend & Key**
    - Small legend below diagram explaining colors
    - Green = Normal, Yellow = Degraded, Red = Critical
    - Icons explanation: what each icon represents
    - Keyboard shortcuts if interactive

14. **Comparison Mode**
    - Toggle to compare current metrics with baseline
    - Show percentage difference from 24-hour average
    - Highlights unusual patterns
    - Useful for performance testing

15. **Export/Share**
    - Screenshot button (uses html2canvas)
    - Save as PNG with timestamp
    - Generate summary report as text
    - Copy diagram as SVG code

## Dependencies

- **Story 2.1-2.5:** Event processing and metrics infrastructure
- **Story 4.2-4.3:** Metrics calculation providing real-time data
- **Story 1.6:** Dashboard UI skeleton

## Technical Specifications

### SVG Flow Diagram

```html
<!-- src/ui/index.html -->
<div id="event-flow-section" class="flow-section">
  <h3>Event Flow Visualization</h3>
  <svg id="flow-diagram" viewBox="0 0 1200 300" class="flow-diagram">
    <!-- Ingestion Stage -->
    <g id="stage-ingestion" class="stage-box" transform="translate(50, 50)">
      <rect class="stage-rect" width="150" height="150" rx="8" data-status="normal"/>
      <text x="75" y="40" class="stage-title">Ingestion</text>
      <text x="75" y="70" class="stage-icon">üì•</text>
      <text x="75" y="100" class="stage-metric" id="metric-ingestion">0</text>
      <text x="75" y="120" class="stage-label">events/sec</text>
    </g>

    <!-- Queue Stage -->
    <g id="stage-queue" class="stage-box" transform="translate(300, 50)">
      <rect class="stage-rect" width="150" height="150" rx="8" data-status="normal"/>
      <text x="75" y="40" class="stage-title">Queue</text>
      <text x="75" y="70" class="stage-icon">‚è≥</text>
      <text x="75" y="100" class="stage-metric" id="metric-queue">0</text>
      <text x="75" y="120" class="stage-label">pending</text>
    </g>

    <!-- Processing Stage -->
    <g id="stage-processing" class="stage-box" transform="translate(550, 50)">
      <rect class="stage-rect" width="150" height="150" rx="8" data-status="normal"/>
      <text x="75" y="40" class="stage-title">Processing</text>
      <text x="75" y="70" class="stage-icon">‚öôÔ∏è</text>
      <text x="75" y="100" class="stage-metric" id="metric-processing">0</text>
      <text x="75" y="120" class="stage-label">in flight</text>
    </g>

    <!-- Storage Stage -->
    <g id="stage-storage" class="stage-box" transform="translate(800, 50)">
      <rect class="stage-rect" width="150" height="150" rx="8" data-status="normal"/>
      <text x="75" y="40" class="stage-title">Storage</text>
      <text x="75" y="70" class="stage-icon">üíæ</text>
      <text x="75" y="100" class="stage-metric" id="metric-storage">0</text>
      <text x="75" y="120" class="stage-label">persisted</text>
    </g>

    <!-- DLQ Stage -->
    <g id="stage-dlq" class="stage-box dlq" transform="translate(550, 250)">
      <rect class="stage-rect" width="150" height="100" rx="8" data-status="normal"/>
      <text x="75" y="35" class="stage-title">Dead Letter</text>
      <text x="75" y="55" class="stage-icon">‚ùå</text>
      <text x="75" y="80" class="stage-metric" id="metric-dlq">0</text>
    </g>

    <!-- Flow Arrows -->
    <defs>
      <marker id="arrowhead" markerWidth="10" markerHeight="10"
              refX="9" refY="3" orient="auto">
        <polygon points="0 0, 10 3, 0 6" fill="#3b82f6" />
      </marker>
    </defs>

    <!-- Ingestion ‚Üí Queue -->
    <line x1="200" y1="125" x2="300" y2="125" class="flow-line"
          stroke="#3b82f6" stroke-width="2" marker-end="url(#arrowhead)"/>
    <text x="245" y="110" class="flow-label" id="throughput-1">0/s</text>

    <!-- Queue ‚Üí Processing -->
    <line x1="450" y1="125" x2="550" y2="125" class="flow-line"
          stroke="#3b82f6" stroke-width="2" marker-end="url(#arrowhead)"/>
    <text x="495" y="110" class="flow-label" id="throughput-2">0/s</text>

    <!-- Processing ‚Üí Storage -->
    <line x1="700" y1="125" x2="800" y2="125" class="flow-line"
          stroke="#3b82f6" stroke-width="2" marker-end="url(#arrowhead)"/>
    <text x="745" y="110" class="flow-label" id="throughput-3">0/s</text>

    <!-- Processing ‚Üí DLQ -->
    <line x1="625" y1="200" x2="625" y2="250" class="flow-line dlq-arrow"
          stroke="#ef4444" stroke-width="2" marker-end="url(#arrowhead)"/>
    <text x="640" y="230" class="flow-label error" id="dlq-rate">0/s</text>
  </svg>

  <!-- Legend -->
  <div class="flow-legend">
    <div class="legend-item">
      <span class="legend-color" style="background: #10b981;"></span>
      <span>Normal Operation</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background: #f59e0b;"></span>
      <span>Degraded (Backlog)</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background: #ef4444;"></span>
      <span>Critical (Failing)</span>
    </div>
  </div>

  <!-- Detailed Metrics -->
  <div id="flow-metrics-detail" class="metrics-detail hidden">
    <div class="detail-card">
      <h4 id="detail-title">Ingestion</h4>
      <div class="detail-metric">
        <span class="detail-label">Total Events:</span>
        <span id="detail-total">0</span>
      </div>
      <div class="detail-metric">
        <span class="detail-label">Rate:</span>
        <span id="detail-rate">0 /sec</span>
      </div>
      <div class="detail-metric">
        <span class="detail-label">Trend:</span>
        <span id="detail-trend">‚Üí</span>
      </div>
      <button id="detail-close" class="btn-close">√ó</button>
    </div>
  </div>
</div>
```

### CSS Styling

```css
/* src/ui/flow-visualization.css */
.flow-section {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
}

.flow-section h3 {
  margin: 0 0 16px 0;
  font-size: 16px;
  font-weight: 600;
}

.flow-diagram {
  width: 100%;
  max-width: 1200px;
  height: auto;
  margin-bottom: 16px;
}

.stage-box {
  cursor: pointer;
  transition: filter 0.2s;
}

.stage-box:hover {
  filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
}

.stage-rect {
  fill: white;
  stroke: #d1d5db;
  stroke-width: 2;
  transition: all 0.3s;
}

.stage-box[data-status="normal"] .stage-rect {
  stroke: #10b981;
  fill: #f0fdf4;
}

.stage-box[data-status="degraded"] .stage-rect {
  stroke: #f59e0b;
  fill: #fefce8;
}

.stage-box[data-status="critical"] .stage-rect {
  stroke: #ef4444;
  fill: #fef2f2;
}

.stage-title {
  text-anchor: middle;
  font-size: 14px;
  font-weight: 600;
  fill: #1f2937;
}

.stage-icon {
  text-anchor: middle;
  font-size: 32px;
}

.stage-metric {
  text-anchor: middle;
  font-size: 18px;
  font-weight: 700;
  fill: #1f2937;
}

.stage-label {
  text-anchor: middle;
  font-size: 12px;
  fill: #6b7280;
}

.flow-line {
  stroke-dasharray: 5, 5;
  stroke-dashoffset: 0;
  animation: flowAnimation 20s linear infinite;
}

@keyframes flowAnimation {
  to {
    stroke-dashoffset: 10;
  }
}

.flow-line.active {
  stroke: #3b82f6;
  stroke-width: 3;
}

.flow-line.error {
  stroke: #ef4444;
}

.dlq-arrow {
  stroke: #ef4444;
  opacity: 0.3;
}

.dlq-arrow.active {
  opacity: 1;
  stroke-width: 3;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.flow-label {
  font-size: 12px;
  fill: #3b82f6;
  font-weight: 500;
}

.flow-label.error {
  fill: #ef4444;
}

.flow-legend {
  display: flex;
  gap: 24px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #e5e7eb;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 2px;
}

.metrics-detail {
  position: absolute;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  max-width: 250px;
  z-index: 100;
}

.metrics-detail.hidden {
  display: none;
}

.detail-card h4 {
  margin: 0 0 12px 0;
  font-size: 14px;
  font-weight: 600;
}

.detail-metric {
  display: flex;
  justify-content: space-between;
  font-size: 13px;
  margin-bottom: 8px;
}

.detail-label {
  color: #6b7280;
}

.detail-metric span:last-child {
  color: #1f2937;
  font-weight: 500;
}

.btn-close {
  position: absolute;
  top: 8px;
  right: 8px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

@media (max-width: 768px) {
  .flow-diagram {
    max-width: 100%;
  }

  .flow-legend {
    flex-direction: column;
    gap: 12px;
  }
}
```

### Flow Visualization JavaScript

```javascript
// src/ui/flow-visualization.js
class FlowVisualization {
  constructor() {
    this.metrics = {};
    this.updateInterval = null;
    this.init();
  }

  init() {
    this.setupEventListeners();
    this.startMetricsUpdate();
  }

  setupEventListeners() {
    // Click stages for detail view
    document.querySelectorAll('.stage-box').forEach(stage => {
      stage.addEventListener('click', (e) => {
        const stageName = stage.id.replace('stage-', '');
        this.showDetailPopover(stageName, e);
      });
    });
  }

  async startMetricsUpdate() {
    // Initial update
    await this.updateMetrics();

    // Update every 2 seconds
    this.updateInterval = setInterval(() => {
      this.updateMetrics();
    }, 2000);
  }

  async updateMetrics() {
    try {
      const response = await fetch('/api/metrics');
      const data = await response.json();

      this.metrics = {
        ingestion: data.events_ingested_rate || 0,
        queue_depth: data.queue_depth || 0,
        processing: data.events_in_flight || 0,
        storage: data.events_stored || 0,
        dlq: data.dlq_count || 0,
        error_rate: data.error_rate || 0,
        success_rate: data.success_rate || 100
      };

      this.updateDisplay();
    } catch (error) {
      console.error('Failed to fetch flow metrics:', error);
    }
  }

  updateDisplay() {
    // Update metric numbers
    this.updateMetricValue('metric-ingestion', this.metrics.ingestion.toFixed(1));
    this.updateMetricValue('metric-queue', this.metrics.queue_depth);
    this.updateMetricValue('metric-processing', this.metrics.processing);
    this.updateMetricValue('metric-storage', this.metrics.storage);
    this.updateMetricValue('metric-dlq', this.metrics.dlq);

    // Update throughput labels
    document.getElementById('throughput-1').textContent = `${this.metrics.ingestion.toFixed(1)}/s`;
    document.getElementById('throughput-2').textContent = `${(this.metrics.processing / 10).toFixed(1)}/s`;
    document.getElementById('throughput-3').textContent = `${(this.metrics.storage / 100).toFixed(1)}/s`;

    // Update status indicators
    this.updateStageStatus('ingestion', this.metrics.success_rate);
    this.updateStageStatus('queue', this.metrics.queue_depth);
    this.updateStageStatus('processing', this.metrics.error_rate);
    this.updateStageStatus('storage', this.metrics.success_rate);

    // Update DLQ visibility
    if (this.metrics.dlq > 0) {
      document.getElementById('stage-dlq').setAttribute('data-status', 'critical');
      document.querySelector('.dlq-arrow').classList.add('active');
    } else {
      document.getElementById('stage-dlq').setAttribute('data-status', 'normal');
      document.querySelector('.dlq-arrow').classList.remove('active');
    }

    // Animate particles if processing
    if (this.metrics.processing > 0) {
      this.animateEventParticles();
    }
  }

  updateMetricValue(elementId, value) {
    const element = document.getElementById(elementId);
    if (element) {
      const oldValue = parseInt(element.textContent);
      element.textContent = value;

      // Add animation for changes
      if (oldValue !== value) {
        element.classList.add('updating');
        setTimeout(() => element.classList.remove('updating'), 300);
      }
    }
  }

  updateStageStatus(stage, metric) {
    const element = document.getElementById(`stage-${stage}`);
    if (!element) return;

    let status = 'normal';
    if (stage === 'queue') {
      if (metric > 100) status = 'degraded';
      if (metric > 500) status = 'critical';
    } else if (metric < 5) {
      status = 'degraded';
    } else if (metric < 10) {
      status = 'critical';
    }

    element.setAttribute('data-status', status);
  }

  animateEventParticles() {
    // Create small particles that travel along the flow
    const container = document.getElementById('flow-diagram');
    const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    particle.setAttribute('r', '4');
    particle.setAttribute('fill', '#3b82f6');
    particle.setAttribute('cx', '100');
    particle.setAttribute('cy', '125');
    particle.classList.add('particle');

    container.appendChild(particle);

    // Animate particle along path
    let position = 100;
    const moveInterval = setInterval(() => {
      position += 5;
      particle.setAttribute('cx', position);

      if (position > 900) {
        particle.remove();
        clearInterval(moveInterval);
      }
    }, 50);

    // Remove particle after animation
    setTimeout(() => {
      if (particle.parentElement) particle.remove();
    }, 16000);
  }

  showDetailPopover(stageName, event) {
    const detail = document.getElementById('flow-metrics-detail');
    const titleEl = document.getElementById('detail-title');
    const totalEl = document.getElementById('detail-total');
    const rateEl = document.getElementById('detail-rate');

    titleEl.textContent = stageName.charAt(0).toUpperCase() + stageName.slice(1);

    const stageData = {
      ingestion: { total: this.metrics.ingestion, label: 'events/sec' },
      queue: { total: this.metrics.queue_depth, label: 'pending' },
      processing: { total: this.metrics.processing, label: 'in flight' },
      storage: { total: this.metrics.storage, label: 'stored' },
      dlq: { total: this.metrics.dlq, label: 'failed' }
    };

    const data = stageData[stageName];
    if (data) {
      totalEl.textContent = data.total;
      rateEl.textContent = `${data.label}`;
    }

    // Position popover near click
    const rect = event.target.getBoundingClientRect();
    detail.style.left = `${rect.right + 10}px`;
    detail.style.top = `${rect.top}px`;
    detail.classList.remove('hidden');

    // Close on button click
    document.getElementById('detail-close').onclick = () => {
      detail.classList.add('hidden');
    };
  }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  window.flowVisualization = new FlowVisualization();
});
```

## Implementation Workflow

1. **Create SVG Diagram**
   - Design stage boxes with icons
   - Create flow arrows between stages
   - Add DLQ branch

2. **Add Styling**
   - Style stage boxes with color indicators
   - Add hover effects
   - Implement responsive layout

3. **Implement Metrics Update**
   - Fetch metrics from `/api/metrics` endpoint
   - Update display values every 2 seconds
   - Animate value changes

4. **Add Status Indicators**
   - Determine status based on metric thresholds
   - Update stage box colors
   - Show trend indicators

5. **Animate Particles**
   - Create event particles that move along flow
   - Spawn based on throughput
   - Transition to DLQ on errors

6. **Detail Popover**
   - Show detailed metrics on stage click
   - Position near mouse
   - Allow dismissal

7. **Test All Scenarios**
   - Submit events and watch flow
   - Verify metric updates
   - Test status color changes

## Verification Checklist

- [ ] SVG diagram displays correctly
- [ ] Responsive on mobile (vertical stacking)
- [ ] Metrics fetch from API and display
- [ ] Metrics update every 2 seconds
- [ ] Status colors change based on thresholds
- [ ] Event particles animate along flow
- [ ] DLQ shows when errors occur
- [ ] Detail popover shows on click
- [ ] Popover closes on button click
- [ ] Throughput labels update
- [ ] Legend displays correctly
- [ ] Animations are smooth

## Notes

- Use SVG for crisp scaling and animation
- Fetch metrics every 2 seconds for real-time feel
- Color thresholds: Queue depth > 100 (yellow), > 500 (red)
- Particle animation gives immediate visual feedback
- Keep animations performant (CSS-based where possible)

## Related Stories

- **4.3:** Metrics calculation providing flow data
- **5.1:** Debug panel (watch events flow after debug submission)

---

## Dev Agent Record

*To be filled by development agent*

---

## QA Results

*To be filled by QA agent*
