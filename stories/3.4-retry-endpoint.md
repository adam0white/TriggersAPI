---
title: "Epic 3.4 - Retry Endpoint: POST /inbox/{event_id}/retry with Queue Reposting & Status Update"
status: "Ready for Development"
epic: "Epic 3: Event Retrieval & Management + Inbox UI"
priority: "P1"
acceptance_criteria:
  - "POST /inbox/{event_id}/retry endpoint implemented"
  - "Endpoint validates event exists and returns 404 if not found"
  - "Endpoint validates event status is 'failed' before allowing retry (returns 409 Conflict if pending/delivered)"
  - "Endpoint increments retry_count field in D1 event record"
  - "Endpoint updates event status from 'failed' to 'retrying' in D1"
  - "Endpoint updates updated_at timestamp to current time in D1"
  - "Endpoint reposts event to Cloudflare Queue for reprocessing"
  - "Event reposted to queue includes event_id, payload, metadata, retry_count"
  - "Response includes event_id, status: 'retrying', new_attempt (retry_count value), timestamp"
  - "Requires Bearer token authentication (401 if missing)"
  - "Concurrent retry requests on same event handled safely"
  - "Retry on already-retrying event returns 409 Conflict (safe)"
  - "Queue message successfully processed by Queue Consumer (Epic 2.2)"
  - "Retried event flows through workflow again (validate → store → metrics)"
  - "Maximum retry attempts enforced by system (max 3 retries before DLQ)"
  - "Performance: Endpoint responds within 150ms at p95"
created_at: "2025-11-11"
modified_at: "2025-11-11"
story_size: "Medium"
depends_on: "Epic 3.1 - Inbox Query Endpoint, Epic 2.2 - Queue Consumer"
---

## Summary

Implement the POST /inbox/{event_id}/retry endpoint that requeues failed events for reprocessing. Validates event status, increments retry counter, updates status, and reposts to the Queue. Enables recovery from transient failures.

## Business Value

Provides manual recovery mechanism for failed events without requiring system redeployment. Operators can retry failed events after debugging or when the underlying issue is resolved. Critical for operational reliability.

## Technical Requirements

### POST /inbox/{event_id}/retry Endpoint

**File Location:** `src/routes/inbox.ts` (add handler)

**Route Handler:**

```typescript
export async function handleRetryEvent(
  request: Request,
  env: Env,
  ctx: ExecutionContext,
  eventId: string
): Promise<Response> {
  const correlationId = request.headers.get('x-correlation-id') || generateUUID();

  try {
    // Validate event_id format
    if (!isValidUUID(eventId)) {
      return errorHandler({
        code: 'INVALID_EVENT_ID',
        message: `Invalid event ID format: ${eventId}`,
        statusCode: 400,
        correlationId,
      });
    }

    const queries = new EventQueries(env.DB);
    const metricsManager = new MetricsManager(env.KV);

    // Retrieve event
    const event = await queries.getEventById(eventId);

    if (!event) {
      console.info(`[${correlationId}] Retry event not found: ${eventId}`);
      return errorHandler({
        code: 'NOT_FOUND',
        message: `Event ${eventId} not found`,
        statusCode: 404,
        correlationId,
      });
    }

    // Validate event is in 'failed' status
    if (event.status !== 'failed') {
      console.warn(
        `[${correlationId}] Cannot retry event with status: ${event.status} (must be 'failed')`
      );
      return errorHandler({
        code: 'INVALID_STATE',
        message: `Event status is '${event.status}', only 'failed' events can be retried`,
        statusCode: 409,
        correlationId,
      });
    }

    // Check if already at max retries (3)
    if (event.retry_count >= 3) {
      console.warn(
        `[${correlationId}] Event exceeded max retries (${event.retry_count}): ${eventId}`
      );
      return errorHandler({
        code: 'MAX_RETRIES_EXCEEDED',
        message: `Event has already been retried ${event.retry_count} times (max: 3)`,
        statusCode: 409,
        correlationId,
      });
    }

    // Increment retry count
    await queries.incrementRetryCount(eventId);

    // Update status to 'retrying'
    await queries.updateEventStatus(eventId, 'retrying');

    // Repost to queue
    const queueMessage = {
      eventId,
      payload: event.payload,
      metadata: event.metadata,
      retryCount: event.retry_count + 1,
      correlationId,
      attempt: 'manual_retry',
    };

    await env.QUEUE.send(queueMessage);

    // Update metrics: moving from 'failed' to 'retrying'
    ctx.waitUntil(
      (async () => {
        try {
          // Decrement failed count
          await metricsManager.decrementEventStatus('failed');
          console.info(`[${correlationId}] Metrics updated for retry: event_id=${eventId}`);
        } catch (err) {
          console.error(`[${correlationId}] Failed to update metrics after retry: ${err}`);
        }
      })()
    );

    const response = {
      data: {
        event_id: eventId,
        status: 'retrying',
        new_attempt: event.retry_count + 1,
        timestamp: new Date().toISOString(),
      },
      timestamp: new Date().toISOString(),
    };

    console.info(
      `[${correlationId}] Event queued for retry: ${eventId}, attempt: ${event.retry_count + 1}`
    );

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
        'X-Correlation-ID': correlationId,
      },
    });
  } catch (error) {
    console.error(`[${correlationId}] Retry event error:`, error);
    return errorHandler({
      code: 'INTERNAL_ERROR',
      message: 'Failed to retry event',
      statusCode: 500,
      correlationId,
    });
  }
}
```

### D1 Query Methods

**File Location:** `src/db/queries.ts` (add/verify methods)

**Methods Required:**

```typescript
export class EventQueries {
  // Already exists from ack endpoint
  async getEventById(eventId: string): Promise<Event | null> {
    const result = await this.db
      .prepare('SELECT * FROM events WHERE event_id = ?')
      .bind(eventId)
      .first<Event>();
    return result || null;
  }

  // Already exists from schema story
  async updateEventStatus(
    eventId: string,
    newStatus: 'pending' | 'delivered' | 'failed' | 'retrying'
  ): Promise<void> {
    const now = new Date().toISOString();
    await this.db
      .prepare('UPDATE events SET status = ?, updated_at = ? WHERE event_id = ?')
      .bind(newStatus, now, eventId)
      .run();
  }

  // Already exists from schema story
  async incrementRetryCount(eventId: string): Promise<void> {
    const now = new Date().toISOString();
    await this.db
      .prepare(`
        UPDATE events
        SET retry_count = retry_count + 1, updated_at = ?
        WHERE event_id = ?
      `)
      .bind(now, eventId)
      .run();
  }
}
```

### Route Registration

**File Location:** `src/index.ts` (update router)

**Register POST retry endpoint:**

```typescript
router.post('/inbox/:event_id/retry', validateAuth, (request, env, context) => {
  const eventId = new URL(request.url).pathname.split('/')[2];
  return handleRetryEvent(request, env, context, eventId);
});
```

### API Response Format

**Success Response (200 OK):**

```json
{
  "data": {
    "event_id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "retrying",
    "new_attempt": 2,
    "timestamp": "2025-11-11T10:35:00Z"
  },
  "timestamp": "2025-11-11T10:35:00Z"
}
```

**Error Response - Event Not Found (404):**

```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "Event 550e8400-e29b-41d4-a716-446655440000 not found",
    "timestamp": "2025-11-11T10:35:00Z",
    "correlation_id": "abc-123-def"
  }
}
```

**Error Response - Invalid State (409):**

```json
{
  "error": {
    "code": "INVALID_STATE",
    "message": "Event status is 'pending', only 'failed' events can be retried",
    "timestamp": "2025-11-11T10:35:00Z",
    "correlation_id": "abc-123-def"
  }
}
```

**Error Response - Max Retries Exceeded (409):**

```json
{
  "error": {
    "code": "MAX_RETRIES_EXCEEDED",
    "message": "Event has already been retried 3 times (max: 3)",
    "timestamp": "2025-11-11T10:35:00Z",
    "correlation_id": "abc-123-def"
  }
}
```

### Queue Message Format

**Event reposted to queue (src/queue/consumer.ts processes):**

```typescript
interface QueueMessage {
  eventId: string;
  payload: Record<string, any>;
  metadata?: Record<string, any>;
  retryCount: number;
  correlationId: string;
  attempt: 'initial' | 'manual_retry' | 'auto_retry';
}
```

The Queue Consumer (Epic 2.2) already handles processing these messages through the Workflow.

### Event Status Lifecycle

```
Normal Path:           Retry Path:
pending →              failed →
delivered             retry (status: retrying)
                      ↓
                      Queue Consumer processes
                      ↓
                      Workflow executes
                      ↓
                      delivered or failed
```

### Metrics Update

The retry operation updates metrics:

```typescript
// Before retry:
metrics:events:failed = N (event counted here)

// After retry (event requeued):
metrics:events:failed = N - 1 (removed from failed)
// Event will be counted in appropriate bucket after workflow completes
```

### Retry Limit Strategy

```
max_retries = 3 (configurable in wrangler.toml or env)

retry_count progression:
0 → Initial processing attempt (automatic)
1 → First manual/automatic retry
2 → Second retry
3 → Third retry (final)
4+ → Rejected (MAX_RETRIES_EXCEEDED)
```

If max retries exceeded, event cannot be retried manually. It remains failed and queued for deletion.

---

## Implementation Notes

### What Gets Done

1. Add `handleRetryEvent()` function to `src/routes/inbox.ts`
2. Register POST /inbox/:event_id/retry route in src/index.ts
3. Implement validation:
   - Event exists (404 if not)
   - Status is 'failed' (409 if not)
   - Retry count < max (409 if max exceeded)
4. Update event: increment retry_count, set status to 'retrying'
5. Repost to Queue with correlation ID
6. Update metrics (eventually consistent)
7. Test locally with retry workflow
8. Verify event reprocessing through queue
9. Commit: `git add src/routes/ src/index.ts && git commit -m "feat: manual retry endpoint for failed events"`

### Development Workflow

1. Ensure Queue Consumer (2.2) is working
2. Create a test event:
   ```bash
   EVENT_ID=$(curl -s -X POST http://localhost:8787/events \
     -H "Authorization: Bearer test-token" \
     -H "Content-Type: application/json" \
     -d '{"payload":{"test":"data"}}' | jq -r '.data.event_id')
   ```
3. Mark event as failed in database (for testing):
   ```bash
   npx wrangler d1 execute triggers-api --local
   # In D1 shell:
   UPDATE events SET status = 'failed', retry_count = 0 WHERE event_id = 'EVENT_ID';
   ```
4. Retry the event:
   ```bash
   curl -X POST "http://localhost:8787/inbox/$EVENT_ID/retry" \
     -H "Authorization: Bearer test-token" | jq
   ```
5. Verify event reprocessed (check workflow logs)
6. Verify status changed to 'retrying' then 'delivered' or 'failed'

### Key Architecture Decisions

**Status 'retrying':** Intermediate state between 'failed' and final state, allows tracking manual retries

**Max 3 Retries:** Prevents infinite retry loops, forces manual investigation after 3 attempts

**Queue Message Includes retry_count:** Allows workflow to track retry history

**Fire-and-Forget Metrics:** Metrics update in background, response returns immediately

---

## Acceptance Criteria Verification Checklist

### Endpoint Implementation
- [ ] POST /inbox/{event_id}/retry route registered
- [ ] Handler in src/routes/inbox.ts
- [ ] Requires Bearer token authentication
- [ ] Returns 401 if token missing

### Status Validation
- [ ] Only 'failed' events can be retried
- [ ] Returns 409 Conflict if status not 'failed'
- [ ] Event not found returns 404
- [ ] Invalid event ID format returns 400

### Retry Limit
- [ ] Tracks retry_count field
- [ ] Increments on each retry
- [ ] Rejects retry if retry_count >= 3
- [ ] Returns 409 MAX_RETRIES_EXCEEDED

### Event Update
- [ ] Status updated to 'retrying' in D1
- [ ] retry_count incremented
- [ ] updated_at timestamp updated
- [ ] All updates atomic/safe

### Queue Reposting
- [ ] Event reposted to Queue after update
- [ ] Message includes all event data
- [ ] Message includes correlation_id
- [ ] Message includes retry_count value
- [ ] Queue Consumer processes retried event

### Workflow Processing
- [ ] Retried event flows through workflow
- [ ] Workflow can succeed (→ delivered) or fail (→ failed)
- [ ] Metrics updated appropriately

### Response Format
- [ ] Returns event_id, status: "retrying", new_attempt
- [ ] new_attempt = retry_count + 1
- [ ] Timestamp in ISO-8601
- [ ] Correlation ID in headers

### Error Handling
- [ ] NOT_FOUND for missing events
- [ ] INVALID_STATE for non-failed events
- [ ] MAX_RETRIES_EXCEEDED error code
- [ ] INVALID_EVENT_ID for bad format
- [ ] All errors include correlation_id

---

## Dependencies & Context

**From:** docs/PRD.md (Epic 3 - Manual Retry - FR-3.3)
**Architecture:** docs/architecture.md (Queue Integration, Workflows)
**Depends On:**
  - Epic 3.1 (GET /inbox to find events)
  - Epic 2.2 (Queue Consumer to process retried events)
  - Epic 2.3 (Workflow to handle reprocessing)

**Enables:**
  - Epic 3.5 (UI with retry button)

---

## Dev Notes

- Correlation ID enables tracing retry through entire pipeline
- Status 'retrying' distinguishes manual retries from initial processing
- Max 3 retries prevents infinite loops (requires manual investigation after)
- Queue message includes all context needed by workflow
- Fire-and-forget metrics: D1 update immediate, KV eventual
- Event can retry multiple times: 0 → 1 → 2 → 3 (stops at 3)

---

## Testing Considerations

### Unit Tests

```typescript
// test/routes/retry.test.ts
describe('POST /inbox/:event_id/retry', () => {
  it('requeues failed event', async () => {
    // Setup: Create failed event
    const eventId = 'test-uuid-123';
    // ... Insert event with status='failed' in test setup ...

    // Test: Retry event
    const response = await fetch(`/inbox/${eventId}/retry`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    expect(json.data.status).toBe('retrying');
    expect(json.data.new_attempt).toBe(1);
  });

  it('rejects retry on pending event', async () => {
    // Setup: Create pending event
    // ... Insert event with status='pending' ...

    // Test: Try to retry pending event
    const response = await fetch(`/inbox/test-uuid/retry`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    expect(response.status).toBe(409);
    const json = await response.json();
    expect(json.error.code).toBe('INVALID_STATE');
  });

  it('enforces max retries limit', async () => {
    // Setup: Create event with retry_count = 3
    // ... Insert event with status='failed', retry_count=3 ...

    // Test: Try to retry
    const response = await fetch(`/inbox/test-uuid/retry`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    expect(response.status).toBe(409);
    const json = await response.json();
    expect(json.error.code).toBe('MAX_RETRIES_EXCEEDED');
  });

  it('returns 404 for non-existent event', async () => {
    const response = await fetch(`/inbox/nonexistent/retry`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });
    expect(response.status).toBe(404);
  });

  it('requires authentication', async () => {
    const response = await fetch(`/inbox/test-uuid/retry`, {
      method: 'POST',
    });
    expect(response.status).toBe(401);
  });

  it('increments retry count', async () => {
    // ... Setup failed event with retry_count = 1 ...

    // Retry event
    await fetch(`/inbox/test-uuid/retry`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer test-token' },
    });

    // Verify in DB: retry_count = 2
    const event = await getEventFromDB('test-uuid');
    expect(event.retry_count).toBe(2);
  });
});
```

### Manual Testing

```bash
# Setup
npx wrangler dev

# In another terminal:

# 1. Create an event
EVENT_ID=$(curl -s -X POST http://localhost:8787/events \
  -H "Authorization: Bearer test-token" \
  -H "Content-Type: application/json" \
  -d '{"payload":{"test":"data"}}' | jq -r '.data.event_id')

echo "Created event: $EVENT_ID"

# 2. Mark as failed (manually in D1 for testing)
npx wrangler d1 execute triggers-api --local
# In D1 shell:
# UPDATE events SET status = 'failed', retry_count = 0 WHERE event_id = 'EVENT_ID';
# .exit

# 3. Retry the event
curl -s -X POST "http://localhost:8787/inbox/$EVENT_ID/retry" \
  -H "Authorization: Bearer test-token" | jq

# Expected:
# {
#   "data": {
#     "event_id": "EVENT_ID",
#     "status": "retrying",
#     "new_attempt": 1,
#     ...
#   }
# }

# 4. Verify event requeued
# Check queue consumer logs - should process the event

# 5. Verify status changed to 'retrying'
curl -s -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?limit=1" | jq '.data[0].status'
# Should show 'retrying'

# 6. Try to retry again (should succeed with new_attempt: 2)
curl -s -X POST "http://localhost:8787/inbox/$EVENT_ID/retry" \
  -H "Authorization: Bearer test-token" | jq '.data.new_attempt'
# Note: This would fail if event already processed to 'delivered'

# 7. Test max retries
# ... Create event with retry_count = 3 ...
curl -s -X POST "http://localhost:8787/inbox/max-retry-event/retry" \
  -H "Authorization: Bearer test-token" | jq '.error.code'
# Expected: "MAX_RETRIES_EXCEEDED"
```

---
