---
title: "Story 6.1 - Performance Testing: Load Simulation UI, Latency Injection, Metrics Capture"
status: "Ready for Development"
epic: "Epic 6: Performance Testing + Final Polish"
priority: "P1"
story_size: "Large"
estimated_hours: 6
created_at: "2025-11-11"
modified_at: "2025-11-11"
---

## Summary

Build a comprehensive performance testing module that enables load simulation, latency injection for testing various network conditions, and real-time metrics capture. Allow developers and demo audiences to stress-test the TriggersAPI system, simulate network delays, and observe how the system performs under load. Capture and visualize performance metrics including throughput, latency percentiles, error rates, and queue processing times.

## Business Value

Demonstrates that TriggersAPI can handle production-level traffic spikes and performs reliably under stress. Enables pre-demo performance validation to ensure smooth presentations. Provides confidence to stakeholders that the system is production-ready. Showcases edge-native architecture benefits (automatic scaling, distributed processing) through live performance metrics. Validates that latency injection testing matches real-world conditions for API consumers.

## Technical Context

**From PRD (NFR-4: Performance & Scalability):**
- System MUST support high event throughput (100+ events/second)
- System MUST maintain sub-100ms latency at p95
- System MUST auto-scale with load
- System MUST validate performance under sustained load
- System MUST provide performance metrics and monitoring

**From PRD (FR-7.2: Performance Testing Mode):**
- Load simulation with configurable rates (1-1000 events/second)
- Latency injection controls for testing delays
- Real-time metrics capture (throughput, latency, errors)
- Performance benchmarking results
- Integration with existing debug panel

**From Architecture:**
- Tail Worker captures all Worker execution metrics
- KV stores aggregated performance statistics
- Metrics accessible via debug endpoints
- Load simulation events generated from debug panel
- Performance dashboard in existing metrics display

**Key Dependencies:**
- Story 1.2: POST /events endpoint for load testing
- Story 5.1: Debug control panel integration point
- Story 5.2: Toast notifications for load operation feedback
- Story 5.4: UI polish and responsive design
- Story 2.5: Metrics collection (KV metrics storage)

## Acceptance Criteria

### 1. Load Simulation UI Control Panel
- Create dedicated "Load Simulation" section in debug panel
- Input controls for:
  - Event rate (events/second): 1, 10, 50, 100, 500, 1000 (presets + custom)
  - Duration (seconds): 10, 30, 60, 300, 600 (presets + custom)
  - Event template selection (use mock templates from Story 5.5)
  - Random variation toggle (randomize payloads between events)
- Start/Stop buttons with proper state management
- Real-time progress indicator showing:
  - Events sent so far
  - Elapsed time
  - Events remaining
  - Current event rate (events/sec)
- Pause/Resume functionality during active load test
- Visual status indicator (idle, running, paused, complete)

### 2. Latency Injection Controls
- Add "Network Simulation" section to debug panel
- Controls for injecting latency into responses:
  - Baseline latency (ms): 0-500 (slider)
  - Jitter (random variance): 0-200ms
  - Packet loss simulation: 0-10% (percentage)
  - Throttle (bandwidth limitation): Off, 3G, 4G, LTE, Full
- Latency applies to all outgoing responses:
  - /events endpoint responses delayed
  - /inbox endpoint responses delayed
  - /acknowledge endpoint responses delayed
  - /retry endpoint responses delayed
- Apply/Clear buttons to enable/disable latency injection
- Visual indicator showing active latency profile
- Preset profiles: "None", "Poor Network", "Mobile 3G", "Mobile 4G", "Satellite"
- Save custom profiles locally (browser storage)
- Help text explaining what each setting tests

### 3. Real-Time Metrics Capture During Load
- Track metrics during load simulation:
  - Total events sent (counter)
  - Events successfully processed (counter)
  - Events failed (counter)
  - Total bytes sent (bandwidth calculation)
  - Request latency: min, max, p50, p95, p99 (milliseconds)
  - Processing rate (events/second, live)
  - Error rate (errors/total, as percentage)
  - Queue depth (if applicable)
  - Worker execution time (from Tail Worker data)
- Store metrics in KV with timestamp for analysis
- Update display every 100-500ms for smooth real-time visualization
- Calculate running averages for latency percentiles

### 4. Performance Metrics Visualization
- Create performance metrics dashboard section:
  - Throughput gauge (events/sec): shows current rate
  - Latency chart: line chart showing p50, p95, p99 over time
  - Error rate gauge: visual indicator of error percentage
  - Queue depth chart: line chart of queue depth over time
  - System load indicator: CPU/memory approximation (from execution times)
- Color-code metrics:
  - Green: Good (latency <100ms, error rate <1%)
  - Yellow: Warning (latency 100-500ms, error rate 1-5%)
  - Red: Critical (latency >500ms, error rate >5%)
- Show min/max/average for each metric
- Reset metrics button to clear data for new test run

### 5. Performance Benchmarking Results
- After load test completes:
  - Summary card showing overall results
  - Total events sent, succeeded, failed
  - Average latency and latency percentiles
  - Error rate and error breakdown
  - Duration of test
  - Events per second sustained rate
- Download results as JSON:
  - Timestamp, event rate, duration in filename
  - Include all metrics with timestamps for analysis
  - Include latency bucket distribution (histograms)
  - Include any errors encountered
- Display pass/fail assessment:
  - Passes if: throughput > 100 events/sec AND latency p95 < 100ms AND error rate < 1%
  - Shows which criteria met/failed
  - Recommendations based on results

### 6. Integration with Debug Panel
- Add "Performance" tab to debug panel tabs:
  - Tab 1: Load Simulation (controls + progress)
  - Tab 2: Network Simulation (latency injection controls)
  - Tab 3: Performance Metrics (live dashboard)
  - Tab 4: Benchmark Results (summary + download)
- Keep metrics persistent during session:
  - Show historical benchmark runs in a list
  - Allow switching between benchmark results
  - Compare multiple runs side-by-side
- Integrate with existing toast notifications:
  - "Load test started: 500 events/sec for 60 seconds"
  - "Load test paused at 30/60 seconds"
  - "Load test completed: 30,000 events, 500 events/sec, 45ms p95"

### 7. Event Template Selection for Load
- Dropdown to select which mock template to use:
  - All templates from Story 5.5 available
  - Default: "user.created" (simplest)
  - Option to rotate templates (different event per request)
- Show template details:
  - Event type and source
  - Payload size (approx bytes)
  - Common fields being tested
- Option to customize specific fields across all generated events:
  - Common customizations: email domain, order amount range, etc.

### 8. Load Profile Presets
- Pre-configured load profiles for common scenarios:
  - "Quick Test": 10 events/sec, 10 seconds (100 total)
  - "Sustained Load": 100 events/sec, 60 seconds (6,000 total)
  - "Stress Test": 500 events/sec, 30 seconds (15,000 total)
  - "Spike Test": Ramp from 50 to 1000 events/sec over 20 seconds
  - "Endurance Test": 50 events/sec, 600 seconds (30,000 total)
- Preset buttons execute configuration immediately
- Show expected metrics: "This will generate ~6000 events in 60 seconds"

### 9. Latency Bucket Analysis
- Histogram showing distribution of latencies:
  - 0-10ms, 10-50ms, 50-100ms, 100-500ms, 500ms+
  - Show count and percentage for each bucket
  - Visual bar chart representation
  - Helps identify if latencies cluster or have outliers
- Show detailed percentile table:
  - p1, p5, p10, p25, p50, p75, p90, p95, p99, p99.9
  - Useful for SLA validation (e.g., "p95 < 100ms")

### 10. Worker Performance Insights
- Integrate Tail Worker metrics:
  - CPU time per request (milliseconds)
  - Wall-clock time per request
  - Memory used during request
  - Number of database queries
  - Cache hit rate (if applicable)
- Compare against baseline metrics:
  - Before load test vs during load test
  - Identify performance degradation
  - Show absolute numbers and percentage changes
- Display in separate "Worker Details" section

### 11. Load Simulation Persistence
- Save load test configuration:
  - Load profile name
  - Event rate, duration, template
  - Network simulation settings
  - Latency injection parameters
- Persist in browser localStorage
- Dropdown to load previous configurations
- Quick re-run button to repeat previous test
- Delete saved configurations

### 12. Error Analysis During Load
- Capture errors during load test:
  - Show error breakdown by type:
    - Network errors (connection refused, timeout)
    - API errors (4xx, 5xx status codes)
    - Validation errors (bad request)
    - Processing errors (queue/workflow failures)
  - Show error rate trend over time
  - Details of most recent errors
  - Common error messages/codes
- Add errors to summary report
- Highlight if error rate exceeds threshold

### 13. Multi-Run Comparison
- After multiple load tests, enable comparisons:
  - Side-by-side throughput comparison
  - Latency distribution comparison
  - Error rate comparison
  - Chart showing metrics across multiple runs
- Export comparison report as JSON/CSV
- Identify performance regressions between runs
- Visual indicators (up/down arrows) showing trends

### 14. Performance Testing Documentation
- Help section in performance tab:
  - What each metric means
  - How to interpret results
  - Recommended settings for different scenarios
  - Common performance testing best practices
  - Link to TriggersAPI architecture doc
- Tooltips on all controls explaining their effect
- Info icon with details on latency injection impact

### 15. System Resource Monitoring
- Show estimated system impact during test:
  - Queue depth trend (during load)
  - Worker warm-up time (first requests vs stabilized)
  - Memory usage in KV store (metrics storage)
  - Database connection pool status (if visible)
  - Network bandwidth consumed (send/receive)
- Alert if queue is backing up excessively
- Recommend reducing load rate if system is saturating
- Show headroom: "System at 60% capacity, can handle more load"

## Dependencies

- **Story 1.2:** API Worker with POST /events, /inbox, /acknowledge, /retry endpoints
- **Story 1.3:** Auth middleware for token validation in load tests
- **Story 2.2:** Queue consumer processing events reliably
- **Story 2.5:** Metrics collection infrastructure (KV storage)
- **Story 4.1:** Tail Worker setup for capturing performance metrics
- **Story 5.1:** Debug control panel layout and structure
- **Story 5.2:** Toast notification system for feedback
- **Story 5.4:** UI polish and styling
- **Story 5.5:** Mock data templates for load test events

## Technical Specifications

### Load Simulation Engine

```typescript
// src/lib/performance-testing.ts

interface LoadTestConfig {
  eventRate: number; // events per second
  duration: number; // seconds
  templateId: string; // from mock templates
  randomizePayloads: boolean;
  authToken: string;
}

interface LoadTestMetrics {
  startTime: number;
  endTime: number;
  totalEvents: number;
  successCount: number;
  failureCount: number;
  latencies: number[]; // all measured latencies
  errors: Array<{ code: string; count: number }>;
  timestamp: number;
}

class PerformanceTestRunner {
  private config: LoadTestConfig;
  private metrics: LoadTestMetrics;
  private running: boolean = false;
  private paused: boolean = false;
  private eventsSent: number = 0;

  constructor(config: LoadTestConfig) {
    this.config = config;
    this.metrics = {
      startTime: 0,
      endTime: 0,
      totalEvents: 0,
      successCount: 0,
      failureCount: 0,
      latencies: [],
      errors: [],
      timestamp: Date.now()
    };
  }

  async start(): Promise<void> {
    this.running = true;
    this.metrics.startTime = Date.now();
    const expectedTotalEvents = this.config.eventRate * this.config.duration;
    const intervalMs = 1000 / this.config.eventRate;

    const deadline = this.metrics.startTime + (this.config.duration * 1000);

    while (Date.now() < deadline && this.running) {
      if (!this.paused) {
        await this.sendEvent();
        this.eventsSent++;
        this.metrics.totalEvents++;
      }

      // Spread events evenly
      await this.sleep(intervalMs);
    }

    this.metrics.endTime = Date.now();
    this.running = false;
  }

  private async sendEvent(): Promise<void> {
    const startTime = performance.now();

    try {
      const event = window.mockDataGenerator.generateEvent(this.config.templateId);

      const response = await fetch('/events', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.config.authToken}`
        },
        body: JSON.stringify(event)
      });

      const latency = performance.now() - startTime;
      this.metrics.latencies.push(latency);

      if (response.ok) {
        this.metrics.successCount++;
      } else {
        this.metrics.failureCount++;
        const status = response.status;
        const error = this.metrics.errors.find(e => e.code === status.toString());
        if (error) {
          error.count++;
        } else {
          this.metrics.errors.push({ code: status.toString(), count: 1 });
        }
      }
    } catch (error) {
      const latency = performance.now() - startTime;
      this.metrics.latencies.push(latency);
      this.metrics.failureCount++;

      const errorCode = error instanceof Error ? error.message : 'unknown';
      const errorEntry = this.metrics.errors.find(e => e.code === errorCode);
      if (errorEntry) {
        errorEntry.count++;
      } else {
        this.metrics.errors.push({ code: errorCode, count: 1 });
      }
    }
  }

  pause(): void {
    this.paused = true;
  }

  resume(): void {
    this.paused = false;
  }

  stop(): void {
    this.running = false;
  }

  getMetrics(): LoadTestMetrics {
    return { ...this.metrics };
  }

  calculateStats() {
    const latencies = this.metrics.latencies.sort((a, b) => a - b);
    return {
      throughput: this.metrics.successCount / ((this.metrics.endTime - this.metrics.startTime) / 1000),
      latencyMin: latencies[0],
      latencyMax: latencies[latencies.length - 1],
      latencyP50: this.percentile(latencies, 0.50),
      latencyP95: this.percentile(latencies, 0.95),
      latencyP99: this.percentile(latencies, 0.99),
      errorRate: (this.metrics.failureCount / this.metrics.totalEvents) * 100
    };
  }

  private percentile(arr: number[], p: number): number {
    const index = Math.ceil(arr.length * p) - 1;
    return arr[Math.max(0, index)];
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Latency Injection Middleware

```typescript
// src/lib/latency-injection.ts

interface LatencyProfile {
  baseLatency: number; // milliseconds
  jitter: number; // random variance (0-jitter)
  packetLoss: number; // 0-100 percentage
  throttle: 'off' | '3g' | '4g' | 'lte' | 'full';
}

class LatencyInjector {
  private profile: LatencyProfile | null = null;
  private enabled: boolean = false;

  setProfile(profile: LatencyProfile): void {
    this.profile = profile;
    this.enabled = true;
  }

  disable(): void {
    this.enabled = false;
  }

  async applyLatency(operation: () => Promise<Response>): Promise<Response> {
    if (!this.enabled || !this.profile) {
      return operation();
    }

    // Check packet loss
    if (Math.random() < this.profile.packetLoss / 100) {
      throw new Error('Simulated packet loss');
    }

    // Calculate delay
    const jitterAmount = Math.random() * this.profile.jitter;
    const delay = this.profile.baseLatency + jitterAmount;

    // Add throttle-based delay (approximate)
    let throttleDelay = 0;
    const throttleDelays: Record<string, number> = {
      '3g': 100,
      '4g': 50,
      'lte': 30,
      'full': 0
    };
    throttleDelay = throttleDelays[this.profile.throttle] || 0;

    const totalDelay = delay + throttleDelay;

    // Simulate delay
    await new Promise(resolve => setTimeout(resolve, totalDelay));

    // Execute operation
    return operation();
  }
}
```

### Metrics Dashboard Component

```typescript
// src/ui/performance-dashboard.ts

class PerformanceDashboard {
  private metricsHistory: LoadTestMetrics[] = [];
  private updateInterval: NodeJS.Timeout | null = null;
  private runner: PerformanceTestRunner | null = null;

  renderPerformanceTab(): HTMLElement {
    const section = document.createElement('div');
    section.className = 'performance-section';
    section.innerHTML = `
      <div class="perf-tabs">
        <button class="perf-tab-btn active" data-tab="load-sim">Load Simulation</button>
        <button class="perf-tab-btn" data-tab="network-sim">Network Simulation</button>
        <button class="perf-tab-btn" data-tab="metrics">Metrics</button>
        <button class="perf-tab-btn" data-tab="results">Results</button>
      </div>

      <!-- Load Simulation Tab -->
      <div id="load-sim-tab" class="perf-tab-content active">
        <h3>Load Simulation</h3>

        <div class="load-config">
          <div class="config-group">
            <label>Event Rate (events/sec)</label>
            <div class="rate-presets">
              <button class="preset-btn" data-rate="1">1</button>
              <button class="preset-btn" data-rate="10">10</button>
              <button class="preset-btn" data-rate="100">100</button>
              <button class="preset-btn" data-rate="500">500</button>
              <button class="preset-btn" data-rate="1000">1000</button>
            </div>
            <input type="number" id="event-rate" min="1" max="10000" value="100" placeholder="Custom rate">
          </div>

          <div class="config-group">
            <label>Duration (seconds)</label>
            <div class="duration-presets">
              <button class="preset-btn" data-duration="10">10s</button>
              <button class="preset-btn" data-duration="30">30s</button>
              <button class="preset-btn" data-duration="60">60s</button>
              <button class="preset-btn" data-duration="300">5m</button>
              <button class="preset-btn" data-duration="600">10m</button>
            </div>
            <input type="number" id="test-duration" min="1" max="3600" value="60" placeholder="Custom duration">
          </div>

          <div class="config-group">
            <label>Event Template</label>
            <select id="event-template">
              <option value="user.created">User Created</option>
              <option value="order.created">Order Created</option>
              <option value="payment.completed">Payment Completed</option>
            </select>
          </div>

          <div class="config-group">
            <label>
              <input type="checkbox" id="randomize-payloads">
              Randomize payloads
            </label>
          </div>
        </div>

        <div class="load-profiles">
          <h4>Quick Profiles</h4>
          <button class="profile-btn" data-profile="quick">Quick Test (10 evt/s, 10s)</button>
          <button class="profile-btn" data-profile="sustained">Sustained (100 evt/s, 60s)</button>
          <button class="profile-btn" data-profile="stress">Stress Test (500 evt/s, 30s)</button>
          <button class="profile-btn" data-profile="endurance">Endurance (50 evt/s, 600s)</button>
        </div>

        <div class="load-controls">
          <button id="start-load-btn" class="btn btn-primary">Start Load Test</button>
          <button id="pause-load-btn" class="btn btn-secondary" disabled>Pause</button>
          <button id="stop-load-btn" class="btn btn-danger" disabled>Stop</button>
        </div>

        <div id="load-progress" class="progress-section hidden">
          <div class="progress-info">
            <span id="progress-events">0 / 6000 events</span>
            <span id="progress-time">0:00 / 1:00</span>
            <span id="progress-rate">0 evt/s</span>
          </div>
          <div class="progress-bar">
            <div id="progress-fill" class="progress-fill"></div>
          </div>
          <div class="status-indicator" id="load-status">Ready</div>
        </div>
      </div>

      <!-- Network Simulation Tab -->
      <div id="network-sim-tab" class="perf-tab-content">
        <h3>Network Simulation</h3>

        <div class="network-config">
          <div class="config-group">
            <label>Baseline Latency (ms)</label>
            <input type="range" id="latency-slider" min="0" max="500" value="0">
            <span id="latency-value">0ms</span>
          </div>

          <div class="config-group">
            <label>Jitter (ms)</label>
            <input type="range" id="jitter-slider" min="0" max="200" value="0">
            <span id="jitter-value">0ms</span>
          </div>

          <div class="config-group">
            <label>Packet Loss (%)</label>
            <input type="range" id="packet-loss-slider" min="0" max="10" value="0">
            <span id="packet-loss-value">0%</span>
          </div>

          <div class="config-group">
            <label>Throttle</label>
            <select id="throttle-select">
              <option value="off">Full Speed</option>
              <option value="4g">4G</option>
              <option value="3g">3G</option>
              <option value="lte">LTE</option>
            </select>
          </div>
        </div>

        <div class="network-presets">
          <h4>Preset Profiles</h4>
          <button class="profile-btn" data-network="none">None (No Latency)</button>
          <button class="profile-btn" data-network="poor">Poor Network</button>
          <button class="profile-btn" data-network="mobile3g">Mobile 3G</button>
          <button class="profile-btn" data-network="mobile4g">Mobile 4G</button>
        </div>

        <div class="network-controls">
          <button id="apply-latency-btn" class="btn btn-primary">Apply</button>
          <button id="clear-latency-btn" class="btn btn-secondary">Clear</button>
        </div>

        <div id="latency-status" class="status-section"></div>
      </div>

      <!-- Metrics Tab -->
      <div id="metrics-tab" class="perf-tab-content">
        <h3>Performance Metrics</h3>

        <div class="metrics-dashboard">
          <div class="metric-card">
            <h4>Throughput</h4>
            <div class="metric-value" id="throughput-metric">0 evt/s</div>
            <div class="metric-gauge" id="throughput-gauge"></div>
          </div>

          <div class="metric-card">
            <h4>Latency p95</h4>
            <div class="metric-value" id="latency-metric">0 ms</div>
            <div class="metric-status" id="latency-status">Good</div>
          </div>

          <div class="metric-card">
            <h4>Error Rate</h4>
            <div class="metric-value" id="error-rate-metric">0%</div>
            <div class="metric-status" id="error-status">Good</div>
          </div>

          <div class="metric-card">
            <h4>Queue Depth</h4>
            <div class="metric-value" id="queue-depth-metric">0</div>
            <div class="metric-gauge" id="queue-gauge"></div>
          </div>
        </div>

        <div class="metrics-charts">
          <div id="latency-chart" class="chart"></div>
          <div id="throughput-chart" class="chart"></div>
          <div id="error-chart" class="chart"></div>
        </div>

        <button id="reset-metrics-btn" class="btn btn-secondary">Reset Metrics</button>
      </div>

      <!-- Results Tab -->
      <div id="results-tab" class="perf-tab-content">
        <h3>Benchmark Results</h3>

        <div id="results-summary" class="results-section hidden">
          <div class="result-card">
            <h4>Test Summary</h4>
            <div class="result-info">
              <p>Total Events: <span id="result-total">0</span></p>
              <p>Success: <span id="result-success">0</span></p>
              <p>Failed: <span id="result-failed">0</span></p>
              <p>Duration: <span id="result-duration">0s</span></p>
            </div>
          </div>

          <div class="result-card">
            <h4>Performance Metrics</h4>
            <div class="result-metrics">
              <p>Throughput: <span id="result-throughput">0 evt/s</span></p>
              <p>Latency (avg): <span id="result-latency-avg">0 ms</span></p>
              <p>Latency (p95): <span id="result-latency-p95">0 ms</span></p>
              <p>Latency (p99): <span id="result-latency-p99">0 ms</span></p>
              <p>Error Rate: <span id="result-error-rate">0%</span></p>
            </div>
          </div>

          <div class="result-card">
            <h4>Assessment</h4>
            <div id="result-assessment" class="assessment"></div>
          </div>
        </div>

        <div class="results-actions">
          <button id="download-results-btn" class="btn btn-primary" disabled>Download Results</button>
          <button id="compare-results-btn" class="btn btn-secondary" disabled>Compare Runs</button>
        </div>

        <div id="results-history" class="results-list">
          <!-- Previous benchmark runs listed here -->
        </div>
      </div>
    `;

    return section;
  }

  async executeLoadTest(config: LoadTestConfig): Promise<void> {
    this.runner = new PerformanceTestRunner(config);
    await this.runner.start();
    this.metricsHistory.push(this.runner.getMetrics());
  }
}
```

## Implementation Workflow

### Phase 1: Setup & Infrastructure
1. Create PerformanceTestRunner class (load simulation engine)
2. Create LatencyInjector class (latency injection middleware)
3. Create PerformanceDashboard class (UI component)
4. Set up metrics storage in KV (key: `perf_metrics_{timestamp}`)
5. Add performance testing routes to debug endpoints

### Phase 2: Load Simulation UI
1. Render load simulation tab in debug panel
2. Implement event rate preset buttons
3. Implement duration preset buttons
4. Add event template selector dropdown
5. Add progress indicator (updating in real-time)
6. Connect Start/Stop buttons to PerformanceTestRunner
7. Implement pause/resume functionality

### Phase 3: Latency Injection
1. Render network simulation tab
2. Implement latency sliders (baseline, jitter, packet loss)
3. Implement throttle selector
4. Implement preset profile buttons
5. Integrate LatencyInjector into fetch wrapper
6. Apply latency to all outgoing API requests

### Phase 4: Metrics Capture
1. Implement metrics tracking in PerformanceTestRunner
2. Capture latency for each request
3. Calculate running percentiles (p50, p95, p99)
4. Store metrics history in KV
5. Calculate error breakdown by type

### Phase 5: Metrics Visualization
1. Render metrics tab with cards for key metrics
2. Implement gauge components (throughput, error rate)
3. Create latency distribution chart
4. Create throughput over time chart
5. Create error rate trend chart
6. Update metrics display every 500ms during test

### Phase 6: Results & Reports
1. Render results tab with summary data
2. Calculate performance assessment (pass/fail criteria)
3. Implement download results button (JSON format)
4. Store results history in browser storage
5. Implement comparison functionality for multiple runs

### Phase 7: Integration & Polish
1. Connect all components in debug panel
2. Add toast notifications for test lifecycle
3. Integrate with existing mock data templates
4. Add help text and tooltips
5. Test all load profiles and network simulations
6. Verify metrics accuracy

## Verification Checklist

- [ ] Load simulation UI renders in debug panel
- [ ] Event rate presets work (1, 10, 100, 500, 1000 evt/s)
- [ ] Custom event rate input works
- [ ] Duration presets work (10, 30, 60, 300, 600 seconds)
- [ ] Custom duration input works
- [ ] Event template selector shows all templates
- [ ] Start button begins load test
- [ ] Progress indicator updates in real-time
- [ ] Stop button halts load test immediately
- [ ] Pause/Resume buttons work correctly
- [ ] Load profiles execute without errors
- [ ] Expected event counts match configuration
- [ ] Latency baseline slider works (0-500ms)
- [ ] Jitter slider works (0-200ms)
- [ ] Packet loss percentage works (0-10%)
- [ ] Throttle selector applies delay
- [ ] Preset network profiles apply correctly
- [ ] Latency injection applies to all endpoints
- [ ] Metrics update in real-time during load
- [ ] Throughput calculated correctly (events/sec)
- [ ] Latency percentiles calculated correctly
- [ ] Error rate calculated correctly
- [ ] Metrics dashboard renders all cards
- [ ] Gauge components display accurately
- [ ] Charts update with new data points
- [ ] Results summary shows after test completes
- [ ] Performance assessment (pass/fail) correct
- [ ] Download results button generates JSON
- [ ] Comparison between runs shows differences
- [ ] Toast notifications appear for test events
- [ ] All errors handled gracefully
- [ ] UI remains responsive during load test
- [ ] Metrics persist for entire session

## Notes

- Load simulation events sent from client (browser) via POST /events
- Actual network requests experience injected latency
- Metrics captured include both client and server timing
- Percentile calculations use actual latency measurements (not estimates)
- Error handling includes network timeouts and API errors
- Performance assessment uses baseline criteria (100+ evt/s, <100ms p95, <1% errors)
- Results downloadable for post-session analysis
- Latency injection simulates realistic network conditions
- Multiple test runs can be compared to detect regressions

## Related Stories

- **1.2:** Event ingestion API endpoint
- **2.2:** Queue consumer for reliable processing
- **2.5:** Metrics infrastructure and KV storage
- **4.1:** Tail Worker for performance capture
- **5.1:** Debug control panel
- **5.2:** Toast notification system
- **5.4:** UI polish and responsive design
- **5.5:** Mock data templates

---

## Story Status

**Created**: 2025-11-11
**Status**: Ready for Development
**Assigned to**: @dev

This story is ready for implementation by the development team. All acceptance criteria are clearly defined with technical specifications provided. Mock data templates from Story 5.5 and debug panel structure from Story 5.1 are available for integration.

