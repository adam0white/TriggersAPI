---
title: "Epic 3.1 - Inbox Query Endpoint: GET /inbox with D1 Query Builder"
status: "Ready for Development"
epic: "Epic 3: Event Retrieval & Management + Inbox UI"
priority: "P0"
acceptance_criteria:
  - "GET /inbox endpoint implemented and accessible at root path"
  - "Endpoint accepts optional status filter query parameter (pending|delivered|failed)"
  - "Endpoint accepts optional timestamp range parameters: from and to (ISO-8601)"
  - "Endpoint accepts pagination parameters: limit (default 50, max 1000) and offset (default 0)"
  - "D1 query builder constructs WHERE clauses for all filter combinations"
  - "Query correctly handles missing filters (returns all events if no filters)"
  - "Returns events array with all fields: event_id, payload, metadata, status, created_at, updated_at, retry_count"
  - "Response includes total count for pagination (total field in response)"
  - "Response includes limit and offset in response body for client pagination"
  - "Query execution completes within 200ms at p95 (D1 performance target)"
  - "Invalid status filter rejected with 400 Bad Request error"
  - "Invalid timestamp format rejected with 400 Bad Request error"
  - "Endpoint requires Bearer token authentication (reuses auth middleware from Epic 1.3)"
  - "Response uses standard API format: {data: [...], total, limit, offset, timestamp}"
  - "Composite index on (status, created_at) is used for optimized query execution"
  - "Handles empty result set gracefully (returns empty array, total: 0)"
created_at: "2025-11-11"
modified_at: "2025-11-11"
story_size: "Medium"
depends_on: "Epic 1.2 - API Worker, Epic 1.3 - Auth Middleware, Epic 2.1 - D1 Schema"
---

## Summary

Implement the GET /inbox endpoint that retrieves events from D1 with filtering and pagination support. This endpoint provides the foundation for browsing stored events through both API and UI, enabling event auditing and troubleshooting.

## Business Value

Enables operators and developers to query historical events from the system. Without this retrieval capability, there's no way to inspect what's in the system or debug issues. The filtering and pagination allow efficient browsing even with thousands of events.

## Technical Requirements

### GET /inbox Endpoint

**File Location:** `src/routes/inbox.ts` (extends existing file from Epic 1)

**Route Handler:**

```typescript
import { Router } from 'itty-router';
import { Event } from '../types/events';
import { EventQueries } from '../db/queries';
import { validateAuth } from '../middleware/auth';
import { errorHandler } from '../middleware/error-handler';

interface InboxRequest {
  status?: 'pending' | 'delivered' | 'failed';
  from?: string;  // ISO-8601 timestamp
  to?: string;    // ISO-8601 timestamp
  limit?: number;
  offset?: number;
}

interface InboxResponse {
  data: Event[];
  total: number;
  limit: number;
  offset: number;
  timestamp: string;
}

export async function handleInboxQuery(
  request: Request,
  env: Env,
  ctx: ExecutionContext
): Promise<Response> {
  try {
    // Parse query parameters
    const url = new URL(request.url);
    const status = url.searchParams.get('status') as 'pending' | 'delivered' | 'failed' | null;
    const from = url.searchParams.get('from');
    const to = url.searchParams.get('to');
    const limit = Math.min(parseInt(url.searchParams.get('limit') || '50'), 1000);
    const offset = parseInt(url.searchParams.get('offset') || '0');

    // Validate status if provided
    if (status && !['pending', 'delivered', 'failed'].includes(status)) {
      return errorHandler({
        code: 'INVALID_STATUS',
        message: `Invalid status: ${status}. Must be one of: pending, delivered, failed`,
        statusCode: 400,
      });
    }

    // Validate timestamp format if provided
    if (from && isNaN(Date.parse(from))) {
      return errorHandler({
        code: 'INVALID_TIMESTAMP',
        message: `Invalid from timestamp: ${from}. Must be ISO-8601 format`,
        statusCode: 400,
      });
    }

    if (to && isNaN(Date.parse(to))) {
      return errorHandler({
        code: 'INVALID_TIMESTAMP',
        message: `Invalid to timestamp: ${to}. Must be ISO-8601 format`,
        statusCode: 400,
      });
    }

    // Validate pagination
    if (offset < 0) {
      return errorHandler({
        code: 'INVALID_OFFSET',
        message: 'offset must be >= 0',
        statusCode: 400,
      });
    }

    // Query D1
    const queries = new EventQueries(env.DB);
    const events = await queries.getEventsByFilters({
      status,
      from,
      to,
      limit,
      offset,
    });

    const total = await queries.countEventsByFilters({
      status,
      from,
      to,
    });

    const response: InboxResponse = {
      data: events,
      total,
      limit,
      offset,
      timestamp: new Date().toISOString(),
    };

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
      },
    });
  } catch (error) {
    console.error('Inbox query error:', error);
    return errorHandler({
      code: 'INTERNAL_ERROR',
      message: 'Failed to query inbox',
      statusCode: 500,
    });
  }
}
```

### D1 Query Builder in EventQueries

**File Location:** `src/db/queries.ts` (extends existing EventQueries class)

**Add these methods:**

```typescript
interface QueryFilters {
  status?: 'pending' | 'delivered' | 'failed';
  from?: string;
  to?: string;
  limit?: number;
  offset?: number;
}

export class EventQueries {
  // ... existing methods ...

  async getEventsByFilters(filters: QueryFilters): Promise<Event[]> {
    const { status, from, to, limit = 50, offset = 0 } = filters;

    // Build WHERE clause dynamically
    const whereClauses: string[] = [];
    const params: any[] = [];

    if (status) {
      whereClauses.push('status = ?');
      params.push(status);
    }

    if (from) {
      whereClauses.push('created_at >= ?');
      params.push(from);
    }

    if (to) {
      whereClauses.push('created_at <= ?');
      params.push(to);
    }

    const whereClause = whereClauses.length > 0
      ? `WHERE ${whereClauses.join(' AND ')}`
      : '';

    // Add pagination params
    params.push(limit, offset);

    const query = `
      SELECT * FROM events
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT ? OFFSET ?
    `;

    const result = await this.db.prepare(query).bind(...params).all<Event>();
    return result.results || [];
  }

  async countEventsByFilters(filters: Omit<QueryFilters, 'limit' | 'offset'>): Promise<number> {
    const { status, from, to } = filters;

    const whereClauses: string[] = [];
    const params: any[] = [];

    if (status) {
      whereClauses.push('status = ?');
      params.push(status);
    }

    if (from) {
      whereClauses.push('created_at >= ?');
      params.push(from);
    }

    if (to) {
      whereClauses.push('created_at <= ?');
      params.push(to);
    }

    const whereClause = whereClauses.length > 0
      ? `WHERE ${whereClauses.join(' AND ')}`
      : '';

    const query = `SELECT COUNT(*) as count FROM events ${whereClause}`;
    const result = await this.db.prepare(query).bind(...params).first<{ count: number }>();

    return result?.count || 0;
  }
}
```

### Route Registration in Main Worker

**File Location:** `src/index.ts` (update router configuration)

**Add route:**

```typescript
router.get('/inbox', validateAuth, handleInboxQuery);
```

### API Response Format

**Success Response (200 OK):**

```json
{
  "data": [
    {
      "event_id": "550e8400-e29b-41d4-a716-446655440000",
      "payload": {
        "user_id": "123",
        "action": "login",
        "timestamp": "2025-11-11T10:30:00Z"
      },
      "metadata": {
        "source": "auth-service",
        "region": "us-east-1"
      },
      "status": "pending",
      "created_at": "2025-11-11T10:30:00Z",
      "updated_at": "2025-11-11T10:30:00Z",
      "retry_count": 0
    }
  ],
  "total": 1523,
  "limit": 50,
  "offset": 0,
  "timestamp": "2025-11-11T10:35:00Z"
}
```

**Error Response (400 Bad Request):**

```json
{
  "error": {
    "code": "INVALID_STATUS",
    "message": "Invalid status: unknown. Must be one of: pending, delivered, failed",
    "timestamp": "2025-11-11T10:35:00Z",
    "correlation_id": "uuid-here"
  }
}
```

### Query Examples

**Basic - No filters:**
```bash
GET /inbox
Authorization: Bearer test-token
```

**Filter by status:**
```bash
GET /inbox?status=pending
Authorization: Bearer test-token
```

**Filter by status and time range:**
```bash
GET /inbox?status=pending&from=2025-11-11T00:00:00Z&to=2025-11-11T23:59:59Z
Authorization: Bearer test-token
```

**With pagination:**
```bash
GET /inbox?status=delivered&limit=100&offset=200
Authorization: Bearer test-token
```

**All filters combined:**
```bash
GET /inbox?status=failed&from=2025-11-10T00:00:00Z&to=2025-11-11T23:59:59Z&limit=50&offset=0
Authorization: Bearer test-token
```

### Performance Considerations

**Index Usage:**

The query builder leverages D1 indexes created in Epic 2.1:
- `idx_events_status`: Used when filtering by status
- `idx_events_created_at`: Used when filtering by timestamp range
- `idx_events_status_created`: Used for combined status + timestamp queries (composite index)

**Query Optimization:**

```sql
-- Query that uses composite index
EXPLAIN QUERY PLAN
SELECT * FROM events
WHERE status = ? AND created_at >= ? AND created_at <= ?
ORDER BY created_at DESC
LIMIT 50 OFFSET 0;

-- Expected output shows index usage:
-- SEARCH events USING INDEX idx_events_status_created (status=? AND created_at>=? AND created_at<=?)
```

**Performance Targets:**

- Simple query (no filters): < 50ms
- Status filter: < 50ms
- Status + time range: < 100ms
- With pagination (large offset): < 150ms
- Max 200ms at p95 for any combination

### Edge Cases & Validation

**Empty Result Sets:**

```json
{
  "data": [],
  "total": 0,
  "limit": 50,
  "offset": 0,
  "timestamp": "2025-11-11T10:35:00Z"
}
```

**Pagination Beyond Available Data:**

```bash
# offset > total returns empty array, not error
GET /inbox?offset=9999
# Returns: data: [], total: 1523, offset: 9999
```

**Invalid Filters Handling:**

- Invalid status: 400 Bad Request with error code "INVALID_STATUS"
- Invalid timestamp: 400 Bad Request with error code "INVALID_TIMESTAMP"
- Invalid limit (>1000): Silently capped at 1000
- Invalid offset (<0): 400 Bad Request

**NULL Handling:**

- Metadata can be NULL (displayed as null in JSON)
- Payload is always present (required field)
- All timestamp fields populated (created_at, updated_at)

---

## Implementation Notes

### What Gets Done

1. Create `src/routes/inbox.ts` with GET /inbox handler
2. Add `getEventsByFilters()` method to EventQueries class
3. Add `countEventsByFilters()` method to EventQueries class
4. Register GET /inbox route in src/index.ts with auth middleware
5. Implement dynamic WHERE clause builder for flexible filtering
6. Add proper error handling and validation
7. Test locally with sample queries
8. Commit: `git add src/routes/ src/db/ src/index.ts && git commit -m "feat: GET /inbox endpoint with filtering and pagination"`

### Development Workflow

1. Ensure D1 schema from Epic 2.1 is in place
2. Start local dev: `npx wrangler dev`
3. Insert test events (via POST /events or database shell)
4. Test queries:
   ```bash
   # No filters
   curl -H "Authorization: Bearer test-token" "http://localhost:8787/inbox"

   # Status filter
   curl -H "Authorization: Bearer test-token" "http://localhost:8787/inbox?status=pending"

   # With pagination
   curl -H "Authorization: Bearer test-token" "http://localhost:8787/inbox?limit=10&offset=0"

   # Combined filters
   curl -H "Authorization: Bearer test-token" "http://localhost:8787/inbox?status=pending&from=2025-11-11T00:00:00Z&limit=50"
   ```
5. Verify response format and performance
6. Test error cases (invalid status, invalid timestamp, etc.)

### Key Architecture Decisions

**Query Builder Approach:** Dynamic WHERE clause construction instead of separate query methods - provides flexibility and DRY code

**Pagination Parameters:** limit/offset (vs cursor pagination) - simpler for UI implementation, acceptable for inbox queries

**Response Includes Total:** Allows UI to know total available records for proper pagination controls

**Composite Index Usage:** Query patterns optimized for common inbox filters (status + time range)

---

## Acceptance Criteria Verification Checklist

### Endpoint Implementation
- [ ] GET /inbox route registered in src/index.ts
- [ ] Handler function exported from src/routes/inbox.ts
- [ ] Requires Bearer token authentication
- [ ] Returns 401 if token missing/invalid

### Query Parameter Support
- [ ] status parameter accepts: pending, delivered, failed
- [ ] from parameter accepts ISO-8601 timestamps
- [ ] to parameter accepts ISO-8601 timestamps
- [ ] limit parameter defaults to 50, max 1000
- [ ] offset parameter defaults to 0
- [ ] All parameters optional (no filters returns all events)

### Query Builder
- [ ] Dynamic WHERE clause construction for status filter
- [ ] Dynamic WHERE clause construction for time range filters
- [ ] Handles missing filters (WHERE clause omitted)
- [ ] Parameterized queries (prevents SQL injection)
- [ ] Index selection confirmed via EXPLAIN QUERY PLAN

### Response Format
- [ ] Returns standard API response: {data, total, limit, offset, timestamp}
- [ ] Data array contains all Event fields
- [ ] Total field shows total matching records
- [ ] Limit and offset echoed in response
- [ ] Timestamp in ISO-8601 format

### Validation & Error Handling
- [ ] Invalid status: 400 Bad Request
- [ ] Invalid timestamp format: 400 Bad Request
- [ ] Invalid offset (negative): 400 Bad Request
- [ ] Empty result set: Returns data: [], total: 0
- [ ] Pagination beyond available: Returns empty array
- [ ] DB errors: 500 Internal Server Error

### Performance
- [ ] Query execution < 200ms at p95
- [ ] Composite index used for status+time range queries
- [ ] Single column indexes available for individual filters
- [ ] Response payload reasonable size (test with limit=1000)

### Integration
- [ ] Auth middleware enforced (Bearer token required)
- [ ] Standard error response format used
- [ ] Correlation IDs included in errors
- [ ] Logs contain query parameters (sanitized)

---

## Dependencies & Context

**From:** docs/PRD.md (Epic 3 - Event Retrieval & Management - FR-3.1)
**Architecture:** docs/architecture.md (API Contracts - GET /inbox)
**Depends On:**
  - Epic 1.2 (API Worker with route handling)
  - Epic 1.3 (Auth middleware)
  - Epic 2.1 (D1 schema with indexes)

**Enables:**
  - Epic 3.2 (Filtering & pagination refinements)
  - Epic 3.5 (UI inbox interface)

---

## Dev Notes

- EventQueries class encapsulates all D1 operations
- Query builder uses parameter binding (?` placeholders) for safety
- WHERE clauses built as array, joined with AND
- Composite index optimized for most common query: status + timestamp range
- Pagination via LIMIT/OFFSET (simpler than cursor pagination)
- Test locally with: `npx wrangler dev` (requires D1 local mode)
- Query performance measured: EXPLAIN QUERY PLAN shows index usage
- Error messages actionable (tell user what went wrong)
- Correlation IDs enable request tracing through logs

---

## Testing Considerations

### Unit Tests

```typescript
// test/routes/inbox.test.ts
describe('GET /inbox', () => {
  it('returns all events when no filters', async () => {
    const response = await fetch('/inbox', {
      headers: { 'Authorization': 'Bearer test-token' },
    });
    const json = await response.json();
    expect(json.data).toBeArray();
    expect(json.total).toBeNumber();
  });

  it('filters by status', async () => {
    const response = await fetch('/inbox?status=pending', {
      headers: { 'Authorization': 'Bearer test-token' },
    });
    const json = await response.json();
    json.data.forEach(e => expect(e.status).toBe('pending'));
  });

  it('returns 400 for invalid status', async () => {
    const response = await fetch('/inbox?status=invalid', {
      headers: { 'Authorization': 'Bearer test-token' },
    });
    expect(response.status).toBe(400);
  });

  it('handles time range filtering', async () => {
    const response = await fetch(
      '/inbox?from=2025-11-11T00:00:00Z&to=2025-11-11T23:59:59Z',
      { headers: { 'Authorization': 'Bearer test-token' } }
    );
    const json = await response.json();
    json.data.forEach(e => {
      const ts = new Date(e.created_at);
      expect(ts.getTime()).toBeGreaterThanOrEqual(new Date('2025-11-11T00:00:00Z').getTime());
      expect(ts.getTime()).toBeLessThanOrEqual(new Date('2025-11-11T23:59:59Z').getTime());
    });
  });

  it('paginates correctly', async () => {
    const page1 = await fetch('/inbox?limit=10&offset=0', {
      headers: { 'Authorization': 'Bearer test-token' },
    }).then(r => r.json());

    const page2 = await fetch('/inbox?limit=10&offset=10', {
      headers: { 'Authorization': 'Bearer test-token' },
    }).then(r => r.json());

    // IDs should be different
    const ids1 = page1.data.map((e: any) => e.event_id);
    const ids2 = page2.data.map((e: any) => e.event_id);
    expect(ids1).not.toEqual(ids2);
  });

  it('requires authentication', async () => {
    const response = await fetch('/inbox');
    expect(response.status).toBe(401);
  });
});
```

### Manual Testing

```bash
# Setup: Create test data
npx wrangler dev

# In another terminal, seed events
for i in {1..50}; do
  curl -X POST http://localhost:8787/events \
    -H "Authorization: Bearer test-token" \
    -H "Content-Type: application/json" \
    -d "{\"payload\":{\"id\":$i,\"type\":\"test\"}}" &
done
wait

# Test 1: No filters
curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox" | jq '.data | length'
# Expected: 50

# Test 2: Status filter
curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?status=pending" | jq '.total'
# Expected: 50 (all should be pending)

# Test 3: Pagination
curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?limit=10&offset=0" | jq '.data | length'
# Expected: 10

curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?limit=10&offset=10" | jq '.data | length'
# Expected: 10

# Test 4: Invalid status
curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?status=invalid" | jq '.error.code'
# Expected: "INVALID_STATUS"

# Test 5: Invalid timestamp
curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?from=not-a-date" | jq '.error.code'
# Expected: "INVALID_TIMESTAMP"

# Test 6: Time range
curl -H "Authorization: Bearer test-token" \
  "http://localhost:8787/inbox?from=2025-11-11T00:00:00Z&to=2025-11-11T23:59:59Z" | jq '.total'
# Expected: number of events created within that range
```

---

## Implementation Notes for Dev Agent

This story requires clean implementation of a database query builder. The key challenge is constructing WHERE clauses dynamically while maintaining type safety and security (parameterized queries).

**Critical Success Factors:**

1. **Query Safety:** Use parameter binding (?) for all WHERE clause values - no string concatenation
2. **Dynamic WHERE:** Build WHERE clauses as array, join with AND - don't hardcode combinations
3. **Index Leverage:** Design queries to use the composite index on (status, created_at)
4. **Pagination:** Implement LIMIT/OFFSET pagination correctly
5. **Error Messages:** Be specific about what's invalid (status vs timestamp vs pagination)

**Common Pitfalls to Avoid:**

- String concatenation in WHERE clause (security risk)
- Multiple separate queries instead of one with WHERE clause
- Forgetting to handle NULL results
- Not validating timestamp format before querying
- Not capping limit at 1000

---
